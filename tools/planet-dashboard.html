<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Planets Dashboard – Hansen Space</title>
  <link rel="stylesheet" href="/styles.css">
  <style>
    /* Dashboard-specific CSS variables */
    :root {
      --cell:200px;      /* size grid cell base - used for scaling */
      --gap:50px;        /* grid gap base */
      --dist-aspect:1000/256; /* native distance chart ratio */
      --dist-planet-base-height-pct: 35%; /* Base height % for Jupiter */
      --dist-planet-min-height-pct: 0.1%;  /* Min height % */
      --dist-planet-max-height-pct: 80%;  /* Max height % */

      --obs-bar-height: 28px;
      --obs-bar-border-radius: 8px;
      --obs-bar-spacing: 18px;
      --obs-label-width: 100px;
    }

    /* Overlays common to dashboard panels and standalone sections */
    .loading-overlay, .error-overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(30,30,30,0.85); 
      display: flex; justify-content: center; align-items: center;
      text-align: center; z-index: 10; color: var(--color-text-primary);
      font-size: 16px; padding: 20px; pointer-events: none;
      border-radius: 8px; 
    }
    .error-overlay {
      color: var(--color-text-error);
      background: rgba(50,0,0,0.85); 
    }

    .dashboard-panel { 
      background: var(--color-dark-grey-panel-bg); 
      border-radius:8px; 
      padding:30px 20px;
      position: relative;
      min-height: 150px;
      overflow: hidden;
    }

    #size-grid {
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(var(--cell),1fr));
      grid-auto-rows:var(--cell);
      gap:var(--gap);
      justify-content:center;
      padding-bottom: 30px; 
    }
    .planet-slot {
      position:relative; display:flex; flex-direction: column;
      justify-content:center; align-items:center;
    }
    .planet-image-container {
      flex-grow: 1; display: flex; justify-content: center; align-items: center;
      width: 100%; height: 100%;
    }
    .planet-image-container img {
      max-width: 100%; max-height: 100%; object-fit: contain;
    }
    .size-label {
      position:absolute; bottom:-26px; left:50%; transform:translateX(-50%);
      font-size:14px; color: var(--color-text-secondary); white-space:nowrap;
    }

    .panel-distance { 
        padding-top:30px; padding-bottom:30px
    }
    #dist-box {
      width:100%; max-width:none; margin:0 auto;
      aspect-ratio: var(--dist-aspect); position:relative; min-height: 150px;
      overflow: visible; 
    }
    .dist-track { position:absolute; top:0; left:0; width:100%; height:100%; }
    .dist-track::before { 
      content:""; position:absolute; top:50%;
      left: 5%; width: 90%; height:2px;
      background: var(--color-light-grey-borders-dividers); transform:translateY(-50%);
     }
    .anchor { 
      position:absolute; left:0; top:50%; z-index: 5; width: auto; max-height: none;
     }
    #dist-planets { 
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      padding: 0; color: var(--color-text-secondary); font-size: 12px;
      line-height: 1.5; font-family: monospace; 
      overflow: visible;
    }
    #dist-planets .dist-planet-img {
      position:absolute; top:50%; transform:translate(-50%, -50%); width:auto;
      min-height: var(--dist-planet-min-height-pct); max-height: var(--dist-planet-max-height-pct);
      z-index: 4; object-fit: contain;
     }
    #dist-planets .dist-label {
      position:absolute; top:calc(50% - 40px); color: var(--color-text-primary); white-space:nowrap;
      transform-origin:top left; transform:rotate(-40deg);
      font-size: clamp(10px, 1.2vw, 14px); z-index: 6;
     }

    #observability-section {
        padding-top: 10px; padding-bottom: 10px;
    }
    #observability-content-area { 
        position: relative; 
        min-height: 100px; 
    }
    #observability-chart {
        padding: 10px 0; 
    }
    .observability-planet-row {
        display: flex;
        align-items: center;
        margin-bottom: var(--obs-bar-spacing);
    }
    .observability-planet-label {
        width: var(--obs-label-width);
        padding-right: 15px;
        text-align: right;
        font-size: 15px; 
        font-weight: 600; 
        color: var(--color-text-primary); 
        text-transform: capitalize;
        flex-shrink: 0; 
    }
    .observability-bar-container {
        flex-grow: 1;
        height: var(--obs-bar-height);
    }
    .observability-bar {
        width: 100%;
        height: 100%;
        border-radius: var(--obs-bar-border-radius);
        background: var(--color-light-grey-borders-dividers); 
        box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
    }
    #observability-content-area .loading-overlay,
    #observability-content-area .error-overlay {
        border-radius: var(--obs-bar-border-radius); 
        background: rgba(46, 46, 46, 0.85); 
    }

    #observability-debug-data {
        margin-top: 30px;
        padding: 20px; 
        background-color: var(--color-dark-grey-panel-bg); 
        border: 1px solid var(--color-light-grey-borders-dividers);
        border-radius: 8px;
        font-family: monospace; 
        font-size: 13px;
        color: var(--color-text-secondary);
    }
    #observability-debug-data h3 { 
        font-family: var(--font-headings); 
        color: var(--color-text-headings); 
        font-size: 1.3rem; 
        margin-bottom: 20px; 
        padding-bottom: 10px;
        border-bottom: 1px solid var(--color-light-grey-borders-dividers);
    }
    #observability-debug-data details {
        margin-bottom: 12px; 
        border: 1px solid var(--color-light-grey-borders-dividers);
        border-radius: 6px; 
        padding: 8px; 
        background-color: rgba(255,255,255,0.02); 
    }
    #observability-debug-data summary {
        cursor: pointer;
        font-weight: bold;
        padding: 10px 8px; 
        color: var(--color-text-primary);
        text-transform: capitalize;
        list-style-position: inside; 
        border-radius: 4px; 
        transition: background-color 0.2s ease;
    }
    #observability-debug-data summary:hover {
        background-color: rgba(255,255,255,0.05);
    }
    #observability-debug-data details[open] > summary { 
        background-color: rgba(255,255,255,0.04);
        border-bottom: 1px solid var(--color-light-grey-borders-dividers);
        margin-bottom: 8px;
    }
    #observability-debug-data .debug-list-container {
        padding-left: 15px; 
        max-height: 350px; 
        overflow-y: auto;
        margin-top: 8px;
        padding-top: 5px;
    }
    #observability-debug-data .debug-day-entry {
        padding: 4px 0; 
        border-bottom: 1px dotted rgba(255,255,255,0.08);
        display: flex; 
        gap: 15px; 
        align-items: center;
    }
    #observability-debug-data .debug-day-entry:last-child { border-bottom: none; }
    #observability-debug-data .debug-day-entry span { display: inline-block; }
    #observability-debug-data .debug-day-entry span.day-num { min-width: 65px; color: var(--color-text-primary); font-weight: 600;}
    #observability-debug-data .debug-day-entry span.data-val { min-width: 85px; color: var(--color-text-secondary); }
    #observability-debug-data .debug-day-entry span.unit { color: #888; font-style: italic; }

    @media (max-width: 850px) {
      :root { 
        --cell: calc(200px * 0.55); --gap: calc(50px * 0.6);
        --dist-planet-base-height-pct: 18%; --dist-planet-max-height-pct: 65%;
        --obs-label-width: 85px; --obs-bar-height: 26px;
      }
      .size-label { font-size:12px }
      #dist-planets .dist-label { font-size: clamp(9px, 1.3vw, 12px); top:calc(50% - 30px); }
      .observability-planet-label { font-size: 14px; }
      .dashboard-panel { padding: 20px 15px; }
      #size-grid { padding-bottom: 20px; }
    }
    @media (max-width: 480px) {
      :root { 
          --cell: calc(200px * 0.45); --gap: calc(50px * 0.5);
          --dist-planet-base-height-pct: 15%; --dist-planet-max-height-pct: 55%;
          --obs-label-width: auto; --obs-bar-height: 24px; --obs-bar-spacing: 16px;
      }
      .size-label { font-size:11px; bottom: -22px; }
      #dist-planets .dist-label { font-size: clamp(8px, 1.5vw, 10px); top:calc(50% - 25px); }
      .observability-planet-row { flex-direction: column; align-items: stretch; }
      .observability-planet-label { text-align: left; width: 100%; margin-bottom: 6px; padding-right: 0;}
      .observability-bar-container { width: 100%; }
      #observability-debug-data { font-size: 11px; padding: 10px; }
      #observability-debug-data h3 { font-size: 1.1rem; margin-bottom: 10px;}
      #observability-debug-data .debug-day-entry span.day-num { min-width: 50px; }
      #observability-debug-data .debug-day-entry span.data-val { min-width: 70px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-inner-container content-limiter">
      <a class="brand" href="/index.html">
        <img src="/images/logo.png" alt="Hansen Space Logo" onerror="this.src='https://placehold.co/200x50/1c1c1c/FFFFFF?text=Hansen+Space'; this.onerror=null;" />
      </a>
      <nav>
        <ul>
          <li><a href="/index.html">Home</a></li>
          <li><a href="/myjourney.html">My Journey</a></li>
          <li><a href="/photography.html">Photography</a></li>
          <li><a href="/articles">Articles</a></li>
          <li><a href="/tools.html">Tools</a></li>
          <li><a href="/contact.html" class="active">Contact</a></li>
        </ul>
      </nav>
      <div class="menu-icon" onclick="toggleModal()">☰</div>
    </div>
  </header>

  <div class="modal-backdrop" id="modal-backdrop" onclick="toggleModal()"></div>
  <div class="modal" id="modal">
    <a href="/index.html">Home</a>
    <a href="/myjourney.html">My Journey</a>
    <a href="/photography.html">Photography</a>
    <a href="/articles">Articles</a>
    <a href="/tools.html">Tools</a>
    <a href="/contact.html" class="active">Contact</a>
  </div>
  <main class="page-main-content-area content-limiter">

    <div class="intro-block"> <h1 class="intro-block__title">PLANET DASHBOARD</h1>
      <p class="intro-block__text">This page shows useful information for observing the planets from Earth and understanding the live status of the Solar System. Planets' polar diameters are used for all angular size, diameter, and visual scaling calculations. All data is current.</p>
    </div>

    <div class="content-divider"></div> <section>
      <div class="section-heading-block"> <h2 class="section-heading-block__title">SIZE</h2>
        <p class="section-heading-block__text">Compare the planets by their actual physical (polar) diameters, or see how large they appear from Earth or the Sun based on their current distance and angular size.</p>
      </div>
      <div class="pill-switch" id="size-mode-switch">
        <button data-mode="trueSize">true size</button>
        <button data-mode="apparentEarth" class="active">apparent size (from Earth)</button>
        <button data-mode="apparentSun">apparent size (from Sun)</button>
      </div>
      <div class="dashboard-panel" id="size-panel">
        <div id="size-grid"></div>
        <div class="loading-overlay" id="size-loading" style="display: none;">Loading Size Data...</div>
        <div class="error-overlay" id="size-error" style="display: none;"></div>
      </div>
    </section>

    <div class="content-divider"></div>

    <section>
      <div class="section-heading-block">
        <h2 class="section-heading-block__title">DISTANCE</h2>
        <p class="section-heading-block__text">Visualize the relative distances of the planets from the Sun, Earth, or any other planet you choose as an anchor point. Distances are updated live.</p>
      </div>
      <div class="pill-switch" id="dist-mode-switch">
        <button data-mode="distSun">from Sun</button>
        <button data-mode="distEarth" class="active">from Earth</button>
        <div class="custom-select-container">
          <button id="custom-dist-button" class="custom-select-button" data-mode="custom">
            <span id="custom-dist-button-text">custom</span>
            <span class="arrow"></span>
          </button>
          <div class="custom-dropdown" id="custom-dist-dropdown">
            <ul id="custom-dist-list"></ul>
          </div>
        </div>
      </div>
      <div class="dashboard-panel panel-distance" id="dist-panel">
        <div id="dist-box">
          <div class="dist-track">
            <img id="dist-anchor" class="anchor" src="planets/earth.png" alt="anchor" onerror="this.src='https://placehold.co/50x50/1c1c1c/a0a0a0?text=Anchor&font=monospace'; this.onerror=null;">
            <div id="dist-planets"></div>
          </div>
        </div>
        <div class="loading-overlay" id="dist-loading" style="display: none;">Loading Distance Data...</div>
        <div class="error-overlay" id="dist-error" style="display: none;"></div>
      </div>
    </section>

    <div class="content-divider"></div>

    <section id="observability-section">
      <div class="section-heading-block">
        <h2 class="section-heading-block__title">IN THE SKY <span style="font-size: 0.6em; color: var(--color-text-secondary); font-weight: 400;">(Next 365 Days)</span></h2>
        <p class="section-heading-block__text">Predicted viewing favorability for each planet over the coming year. Brighter colors (towards green) indicate better chances to observe, considering factors like brightness (magnitude) and angular separation from the Sun (elongation). Darker (towards red) means less favorable.</p>
      </div>
      <div id="observability-content-area">
        <div id="observability-chart"></div>
        <div class="loading-overlay" id="obs-loading" style="display: none;">Loading Observability Data...</div>
        <div class="error-overlay" id="obs-error" style="display: none;"></div>
      </div>
      <div id="observability-debug-data" style="display: block;">
        </div>
    </section>

  </main>

  <footer> <div class="footer-inner-container content-limiter">
      <div class="social-links">
        <a href="#"><img src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/youtube.svg" alt="YouTube"></a>
        <a href="#"><img src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/instagram.svg" alt="Instagram"></a>
        <a href="#"><img src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/tiktok.svg" alt="TikTok"></a>
      </div>
      <p>© <span id="year"></span> Hansen Space. All Rights Reserved.</p>
    </div>
    <script>document.getElementById('year').textContent = new Date().getFullYear();</script>
  </footer>

 <script>
    // --- Static Data ---
    const PLANET_META = { mercury: 4877, venus: 12104, earth: 12714, mars: 6752, jupiter: 133708, saturn: 108728, uranus: 49946, neptune: 48682, sun: 1392700 };
    const PLANET_SMA = { mercury: 0.387, venus: 0.723, earth: 1, mars: 1.524, jupiter: 5.203, saturn: 9.537, uranus: 19.191, neptune: 30.068 };
    const PLANET_ORDER = ["mercury", "venus", "earth", "mars", "jupiter", "saturn", "uranus", "neptune"];
    const OBSERVABLE_PLANETS = ["mercury", "venus", "mars", "jupiter", "saturn", "uranus", "neptune"];
    const AU_KM = 149597870.7;
    const REFRESH_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes

    const MAX_ELONGATIONS = { mercury: 28, venus: 47, mars: 180, jupiter: 180, saturn: 180, uranus: 180, neptune: 180 };
    const MAGNITUDE_RANGES = {
        mercury: [5.5, -2.0], venus: [-3.8, -4.9], mars: [1.8, -2.9],
        jupiter: [-1.6, -2.9], saturn: [1.4, -0.5], uranus: [5.9, 5.3], neptune: [8.0, 7.7]
    };
    const TARGET_MAG_SCORE_MIN_MAG = -4.6; 
    const TARGET_MAG_SCORE_MAX_MAG = 8.0;  
    const TARGET_MAG_SCORE_RANGE = TARGET_MAG_SCORE_MAX_MAG - TARGET_MAG_SCORE_MIN_MAG;

    // --- Helper Functions ---
    function getCssVariableValue(varName) {
        console.log(`[LOG] getCssVariableValue called for: ${varName}`);
        const value = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        const floatVal = parseFloat(value);
        console.log(`[LOG] ${varName} raw value: "${value}", parsed: ${floatVal}`);
        return floatVal || 0; 
    }

    function getTargetMaxPxSize() {
        // console.log("[LOG] getTargetMaxPxSize called"); // Can be spammy if called often
        const cellElement = document.getElementById('size-grid') || document.documentElement;
        const computedCellStyle = getComputedStyle(cellElement);
        let cellBaseSize = parseFloat(computedCellStyle.getPropertyValue('--cell'));
        // console.log(`[LOG] Initial --cell from computed: ${cellBaseSize}`);

        if (isNaN(cellBaseSize) || cellBaseSize <=0) {
            const rootStyle = getComputedStyle(document.documentElement);
            const rawCellVar = rootStyle.getPropertyValue('--cell').trim();
            console.warn(`[WARN] Fallback --cell from root: "${rawCellVar}"`);
            if (rawCellVar && rawCellVar.includes('px')) {
                cellBaseSize = parseFloat(rawCellVar);
            }
            if (isNaN(cellBaseSize) || cellBaseSize <=0) {
                console.warn("[WARN] --cell not parseable, using fallback 190px");
                cellBaseSize = 190; 
            }
        }
        const targetSize = cellBaseSize * 0.5;
        const finalSize = Math.max(60, targetSize);
        // console.log(`[LOG] getTargetMaxPxSize final: ${finalSize}`);
        return finalSize;
    }

    // --- State Variables ---
    let BASE_PLANET_VISUAL_HEIGHT_PCT = 35; 
    let MIN_PLANET_VISUAL_HEIGHT_PCT = 5;  
    let MAX_PLANET_VISUAL_HEIGHT_PCT = 80; 

    let currentSizeMode = 'apparentEarth';
    let currentDistMode = 'distEarth';
    let selectedCustomPlanet = null;
    let liveApiData = null; 
    let apiFetchError = null;
    let apiRefreshTimer = null;
    let hasLoggedApiStructure = false; // Re-added from original code for API debugging

    const displayData = {
        trueSize: { planets: {}, requires_live: false, status: 'pending', error: null },
        apparentEarth: { planets: {}, requires_live: true, status: 'pending', error: null },
        apparentSun: { planets: {}, requires_live: false, status: 'pending', error: null },
        distSun: { planets: {}, requires_live: false, status: 'pending', error: null },
        distEarth: { planets: {}, requires_live: true, status: 'pending', error: null },
        observability: { planets: {}, status: 'pending', error: null } 
    };
    let customDistanceData = {};
    let customDistanceStatus = 'pending';
    let customDistanceError = null;

    // --- DOM Element References ---
    const sizeGrid = document.getElementById('size-grid');
    const distAnchor = document.getElementById('dist-anchor');
    const distPlanetsContainer = document.getElementById('dist-planets');
    const sizeLoading = document.getElementById('size-loading');
    const sizeError = document.getElementById('size-error');
    const distLoading = document.getElementById('dist-loading');
    const distError = document.getElementById('dist-error');
    const customDistButton = document.getElementById('custom-dist-button');
    const customDistButtonText = document.getElementById('custom-dist-button-text');
    const customDistDropdown = document.getElementById('custom-dist-dropdown');
    const customDistList = document.getElementById('custom-dist-list');
    const obsSection = document.getElementById('observability-section');
    const obsChartContainer = document.getElementById('observability-chart');
    const obsLoading = document.getElementById('obs-loading'); 
    const obsError = document.getElementById('obs-error');   
    const obsDebugContainer = document.getElementById('observability-debug-data');


    // --- Utility Functions ---
    function toRadians(degrees) { /* console.log(`[LOG] toRadians(${degrees})`); */ return degrees * Math.PI / 180; }
    function getAngularSizeArcsec(diameterKm, distanceAu) {
        // console.log(`[LOG] getAngularSizeArcsec(diam: ${diameterKm}, distAU: ${distanceAu})`);
        if (!diameterKm || !distanceAu || distanceAu <= 0) { console.warn(`[WARN] Invalid input for getAngularSizeArcsec`); return 0; }
        const distanceKm = distanceAu * AU_KM;
        const radiusKm = diameterKm / 2;
        const radians = 2 * Math.atan(radiusKm / distanceKm);
        return radians * 206264.806; 
    }
    function calculateAngularSeparation(ra1Rad, dec1Rad, ra2Rad, dec2Rad) {
        // console.log(`[LOG] calculateAngularSeparation(ra1: ${ra1Rad}, dec1: ${dec1Rad}, ra2: ${ra2Rad}, dec2: ${dec2Rad})`);
        if ([ra1Rad, dec1Rad, ra2Rad, dec2Rad].some(val => typeof val !== 'number' || isNaN(val))) {console.warn(`[WARN] Invalid input for calculateAngularSeparation`); return NaN;}
        const cosAngle = Math.sin(dec1Rad) * Math.sin(dec2Rad) + Math.cos(dec1Rad) * Math.cos(dec2Rad) * Math.cos(ra1Rad - ra2Rad);
        const clampedCosAngle = Math.max(-1, Math.min(1, cosAngle)); 
        return Math.acos(clampedCosAngle);
    }
    function lawOfCosines(distA_earth, distB_earth, angleA_E_B_rad) {
        // console.log(`[LOG] lawOfCosines(distA: ${distA_earth}, distB: ${distB_earth}, angleRad: ${angleA_E_B_rad})`);
        if (isNaN(distA_earth) || isNaN(distB_earth) || isNaN(angleA_E_B_rad) || distA_earth < 0 || distB_earth < 0) {console.warn(`[WARN] Invalid input for lawOfCosines`); return NaN;}
        if (distA_earth === 0) return distB_earth; 
        if (distB_earth === 0) return distA_earth; 
        const distSq = Math.pow(distA_earth, 2) + Math.pow(distB_earth, 2) - 2 * distA_earth * distB_earth * Math.cos(angleA_E_B_rad);
        return Math.sqrt(Math.max(0, distSq)); 
    }

    // --- ORIGINAL DASHBOARD DATA CALCULATION FUNCTIONS ---
    function calculateTrueSizeData() {
        console.log("[Calc] Calculating True Size data...");
        const modeData = displayData.trueSize; modeData.planets = {}; modeData.status = 'pending'; modeData.error = null;
        const targetMaxPx = getTargetMaxPxSize();
        let maxDiameter = 0; const diameters = {};
        PLANET_ORDER.forEach(p => { diameters[p] = PLANET_META[p]; if (diameters[p] > maxDiameter) maxDiameter = diameters[p]; });
        if (maxDiameter <= 0) { console.error("[Calc True Size] Max diameter invalid."); modeData.status = 'error'; modeData.error = 'Invalid planet data'; return; }
        PLANET_ORDER.forEach(p => { const diameter = diameters[p]; const px = Math.max(4, (diameter / maxDiameter) * targetMaxPx); modeData.planets[p] = { px: px, label: `${diameter.toLocaleString()} km` }; });
        modeData.status = 'ok'; console.log(`[Calc True Size] Data calculated. Target Px: ${targetMaxPx}`);
    }

    function calculateApparentSunData() {
        console.log("[Calc] Calculating Apparent Size from Sun data (using SMA)...");
        const modeData = displayData.apparentSun; modeData.planets = {}; modeData.status = 'pending'; modeData.error = null;
        const targetMaxPx = getTargetMaxPxSize();
        let maxArcSec = 0; const arcSecs = {};
        PLANET_ORDER.forEach(p => { const diameter = PLANET_META[p]; const distanceAu = PLANET_SMA[p]; const arcSec = getAngularSizeArcsec(diameter, distanceAu); arcSecs[p] = arcSec; if (arcSec > maxArcSec) maxArcSec = arcSec; });
        if (maxArcSec <= 0) { console.error("[Calc Apparent Sun] Max arcsec invalid."); modeData.status = 'error'; modeData.error = 'Calculation error'; return; }
        PLANET_ORDER.forEach(p => { const arcSec = arcSecs[p]; const px = Math.max(4, (arcSec / maxArcSec) * targetMaxPx); modeData.planets[p] = { px: px, label: `${arcSec.toFixed(1)}″` }; });
        modeData.status = 'ok'; console.log(`[Calc Apparent Sun] Data calculated. Max Arcsec: ${maxArcSec}, Target Px: ${targetMaxPx}`);
    }

    function calculateVisualHeightPct(planetId) {
        // console.log(`[Calc] Calculating Visual Height Pct for ${planetId}`); // Can be spammy
        const currentMinPct = getCssVariableValue('--dist-planet-min-height-pct') || MIN_PLANET_VISUAL_HEIGHT_PCT;
        const currentBasePct = getCssVariableValue('--dist-planet-base-height-pct') || BASE_PLANET_VISUAL_HEIGHT_PCT;
        const currentMaxPct = getCssVariableValue('--dist-planet-max-height-pct') || MAX_PLANET_VISUAL_HEIGHT_PCT;
        const jupiterDiameter = PLANET_META.jupiter;
        if (!jupiterDiameter) return currentMinPct; 
        let diameterToUse = PLANET_META[planetId];
        if (!diameterToUse) return currentMinPct; 
        const rawVisualHeightPct = (diameterToUse / jupiterDiameter) * currentBasePct;
        return Math.max(currentMinPct, Math.min(currentMaxPct, rawVisualHeightPct));
    }

    function calculateDistSunData() {
        console.log("[Calc] Calculating Distance from Sun data (using SMA)...");
        const modeData = displayData.distSun; modeData.planets = {}; modeData.status = 'pending'; modeData.error = null;
        const maxDist = PLANET_SMA.neptune;
        PLANET_ORDER.forEach(p => {
            const distanceAu = PLANET_SMA[p];
            const pos = (distanceAu / maxDist) * 100;
            const visualHeightPct = calculateVisualHeightPct(p); 
            modeData.planets[p] = { pos: pos, label: `${distanceAu.toFixed(3)} AU`, visH: visualHeightPct };
        });
        modeData.status = 'ok'; console.log("[Calc Dist Sun] Data calculated.");
    }
    
    function calculateApparentEarthData(processedApiData) {
        console.log("[Calc] Calculating Apparent Size from Earth data...");
        const modeData = displayData.apparentEarth; modeData.planets = {}; modeData.status = 'pending'; modeData.error = null;
        if (!processedApiData) { console.error("[Calc Apparent Earth] Missing processedApiData."); modeData.status = 'error'; modeData.error = 'API data not available'; return; }
        const targetMaxPx = getTargetMaxPxSize();
        let maxArcSec = 0; const arcSecs = {}; let calculationOk = true; let firstErrorLogged = false;
        PLANET_ORDER.forEach(p => { 
            if (p === 'earth') return;
            const diameter = PLANET_META[p];
            const planetData = processedApiData[p];
            const distanceAu = planetData?.distEarth; 
            if (isNaN(distanceAu) || distanceAu <= 0) { console.warn(`[Calc Apparent Earth] Missing/invalid distance for ${p}.`); if (!firstErrorLogged && !hasLoggedApiStructure) { console.log("[Calc Apparent Earth] Logging full processedApiData:", JSON.stringify(processedApiData, null, 2)); firstErrorLogged = true; hasLoggedApiStructure = true; } arcSecs[p] = -1; calculationOk = false;
            } else { const arcSec = getAngularSizeArcsec(diameter, distanceAu); arcSecs[p] = arcSec; if (arcSec > maxArcSec) maxArcSec = arcSec; }
        });
        if (!calculationOk && maxArcSec <= 0) { console.error("[Calc Apparent Earth] No valid distances found."); modeData.status = 'error'; modeData.error = 'Could not read valid planet distances from API data.'; return; }
        if (maxArcSec <= 0) { console.warn("[Calc Apparent Earth] Max calculated arcsec is zero."); maxArcSec = 1; } 
        PLANET_ORDER.forEach(p => { 
             if (p === 'earth') return;
             const arcSec = arcSecs[p];
             if (arcSec < 0) { modeData.planets[p] = { px: 4, label: `??” (No data)` }; } 
             else { const px = Math.max(4, (arcSec / maxArcSec) * targetMaxPx); modeData.planets[p] = { px: px, label: `${arcSec.toFixed(1)}″` }; }
        });
        modeData.status = calculationOk ? 'ok' : 'partial'; modeData.error = calculationOk ? null : 'API data missing required distance field for some planets.';
        console.log(`[Calc Apparent Earth] Data calculated (Status: ${modeData.status}). Max Arcsec: ${maxArcSec}, Target Px: ${targetMaxPx}`);
    }

    function calculateDistEarthData(processedApiData) {
        console.log("[Calc] Calculating Distance from Earth data...");
        const modeData = displayData.distEarth; modeData.planets = {}; modeData.status = 'pending'; modeData.error = null;
        if (!processedApiData) { console.error("[Calc Dist Earth] Missing processedApiData."); modeData.status = 'error'; modeData.error = 'API data not available'; return; }
        const distances = []; let calculationOk = true; let firstErrorLogged = false;
        PLANET_ORDER.forEach(p => {
            if (p === 'earth') return;
            const planetData = processedApiData[p];
            const distanceAu = planetData?.distEarth; 
            if (!isNaN(distanceAu) && distanceAu > 0) {
                distances.push({ id: p, dist: distanceAu });
                const visualHeightPct = calculateVisualHeightPct(p); 
                modeData.planets[p] = { visH: visualHeightPct, label: `${distanceAu.toFixed(3)} AU` };
            } else { console.warn(`[Calc Dist Earth] Missing/invalid distance for ${p}. Excluding.`); if (!firstErrorLogged && !hasLoggedApiStructure) { console.log("[Calc Dist Earth] Logging full processedApiData:", JSON.stringify(processedApiData, null, 2)); firstErrorLogged = true; hasLoggedApiStructure = true; } calculationOk = false; }
        });
        if (distances.length === 0) { console.error("[Calc Dist Earth] No valid distances found."); modeData.status = 'error'; modeData.error = 'Could not read valid planet distances from API data.'; return; }
        const maxDist = Math.max(...distances.map(item => item.dist)); console.log(`[Calc Dist Earth] Max distance (AU): ${maxDist}`);
        distances.forEach(item => { const p = item.id; const distanceAu = item.dist; const pos = (maxDist > 0) ? (distanceAu / maxDist) * 100 : 0; if (modeData.planets[p]) { modeData.planets[p].pos = pos; } });
        modeData.status = calculationOk ? 'ok' : 'partial'; modeData.error = calculationOk ? null : 'API data missing required distance field for some planets.';
        console.log(`[Calc Dist Earth] Data calculated (Status: ${modeData.status})`);
    }

    function calculateAllCustomDistData(processedApiData) {
        console.log("[Calc Custom] Calculating all custom distances...");
        customDistanceData = {}; 
        customDistanceStatus = 'pending';
        customDistanceError = null;
        if (!processedApiData) { console.error("[Calc Custom] Missing processedApiData."); customDistanceStatus = 'error'; customDistanceError = 'API data not available'; return; }
        let overallOk = true; 
        try {
            OBSERVABLE_PLANETS.forEach(anchorId => { // Using OBSERVABLE_PLANETS for anchors
                customDistanceData[anchorId] = { planets: {}, status: 'pending', error: null };
                const anchorData = processedApiData[anchorId];
                if (!anchorData || isNaN(anchorData.raRad) || isNaN(anchorData.decRad) || isNaN(anchorData.distEarth)) {
                    console.warn(`[Calc Custom] Invalid/missing base data for anchor ${anchorId}.`);
                    customDistanceData[anchorId].status = 'error'; customDistanceData[anchorId].error = `Missing base data for ${anchorId}`; overallOk = false; return;
                }
                const targetPlanets = [...PLANET_ORDER]; 
                let anchorSpecificOk = true;
                targetPlanets.forEach(targetId => {
                    if (targetId === anchorId) return; 
                    const targetData = processedApiData[targetId];
                    if (!targetData || isNaN(targetData.raRad) || isNaN(targetData.decRad) || isNaN(targetData.distEarth)) {
                         console.warn(`[Calc Custom] Invalid/missing data for target ${targetId} (anchor ${anchorId}).`);
                         customDistanceData[anchorId].planets[targetId] = { dist: 'N/A', label: 'N/A', visH: calculateVisualHeightPct(targetId) }; anchorSpecificOk = false; overallOk = false; return;
                    }
                    const angularSepRad = calculateAngularSeparation(anchorData.raRad, anchorData.decRad, targetData.raRad, targetData.decRad);
                    const distanceAU = lawOfCosines(anchorData.distEarth, targetData.distEarth, angularSepRad);
                    if (isNaN(distanceAU)) { console.warn(`[Calc Custom] Calculation failed for ${anchorId} -> ${targetId}.`); customDistanceData[anchorId].planets[targetId] = { dist: 'Error', label: 'Error', visH: calculateVisualHeightPct(targetId) }; anchorSpecificOk = false; overallOk = false; }
                    else { customDistanceData[anchorId].planets[targetId] = { dist: distanceAU, label: `${distanceAU.toFixed(3)} AU`, visH: calculateVisualHeightPct(targetId) }; }
                });
                customDistanceData[anchorId].status = anchorSpecificOk ? 'ok' : 'partial';
            });
        } catch (error) { console.error("[Calc Custom] Error during calculation loop:", error); customDistanceStatus = 'error'; customDistanceError = `Calculation error: ${error.message}`; return; }
        customDistanceStatus = overallOk ? 'ok' : 'partial';
        customDistanceError = overallOk ? null : 'Could not calculate some inter-planet distances.';
        console.log(`[Calc Custom] Finished calculations (Status: ${customDistanceStatus}).`);
    }
    
    // --- NEW/UPDATED Observability Calculation Functions ---
    function getObservabilityColor(combinedScore) {
        // console.log(`[LOG] getObservabilityColor for score: ${combinedScore}`); 
        const s = Math.max(0, Math.min(10, combinedScore)); 
        if (s <= 1.5) return '#D32F2F'; if (s <= 3.0) return '#F44336';
        if (s <= 4.5) return '#FF9800'; if (s <= 6.0) return '#FFC107';
        if (s <= 7.5) return '#FFEB3B'; if (s <= 9.0) return '#8BC34A';
        return '#4CAF50';               
    }

    function calculateMagnitudeScore(magnitude) {
        // console.log(`[LOG] calculateMagnitudeScore for mag: ${magnitude}`); 
        if (typeof magnitude !== 'number' || isNaN(magnitude)) { console.warn(`[WARN] Invalid magnitude for score calc: ${magnitude}`); return 1; }
        let score = 10 - 9 * ((magnitude - TARGET_MAG_SCORE_MIN_MAG) / TARGET_MAG_SCORE_RANGE);
        return Math.max(1, Math.min(10, score)); 
    }

    function calculateElongationScore(elongationDegrees, maxPossibleElongation) {
        // console.log(`[LOG] calculateElongationScore for elong: ${elongationDegrees}, max: ${maxPossibleElongation}`); 
        if (typeof elongationDegrees !== 'number' || isNaN(elongationDegrees) ||
            typeof maxPossibleElongation !== 'number' || isNaN(maxPossibleElongation) || maxPossibleElongation <= 0) {
            console.warn(`[WARN] Invalid elongation/maxPossibleElongation for score calc: ${elongationDegrees}, ${maxPossibleElongation}`);
            return 1; 
        }
        let score = 1 + 9 * (Math.abs(elongationDegrees) / maxPossibleElongation);
        return Math.max(1, Math.min(10, score)); 
    }

    function calculateObservabilityData() {
        console.log("[LOG] calculateObservabilityData START");
        const modeData = displayData.observability;
        modeData.planets = {}; modeData.status = 'pending'; modeData.error = null;

        OBSERVABLE_PLANETS.forEach((planetId, planetIndex) => {
            console.log(`[LOG] Calculating observability for ${planetId}`);
            const planetMagRange = MAGNITUDE_RANGES[planetId] || [TARGET_MAG_SCORE_MAX_MAG, TARGET_MAG_SCORE_MIN_MAG]; 
            const planetMaxElong = MAX_ELONGATIONS[planetId] || 180;

            const mockMagnitudes = []; const mockElongations = [];
            const dailyMagnitudeScores = []; const dailyElongationScores = []; const dailyCombinedScores = [];

            const magCyclePeriod = 180 + planetIndex * 30; 
            const elongCyclePeriod = (planetMaxElong === 180) ? (365 + planetIndex * 15) : (120 + planetIndex * 40); 
            const magPhase = (planetIndex / OBSERVABLE_PLANETS.length) * Math.PI * 2;
            const elongPhase = ((planetIndex * 0.7) / OBSERVABLE_PLANETS.length) * Math.PI * 2; 

            for (let day = 0; day < 365; day++) {
                const magProgress = Math.sin((day / magCyclePeriod) * Math.PI * 2 + magPhase); 
                const currentMockMag = planetMagRange[0] + (planetMagRange[1] - planetMagRange[0]) * ((magProgress + 1) / 2);
                mockMagnitudes.push(parseFloat(currentMockMag.toFixed(1)));

                let currentMockElong;
                if (planetMaxElong === 180) { 
                    currentMockElong = 90 + 90 * Math.cos((day / elongCyclePeriod) * Math.PI * 2 + elongPhase); 
                } else { 
                    currentMockElong = planetMaxElong * ( (Math.sin((day / elongCyclePeriod) * Math.PI * 2 + elongPhase) + 1) / 2);
                }
                mockElongations.push(parseFloat(currentMockElong.toFixed(1)));

                const magScore = calculateMagnitudeScore(currentMockMag);
                const elongScore = calculateElongationScore(currentMockElong, planetMaxElong); // Corrected variable name here
                dailyMagnitudeScores.push(parseFloat(magScore.toFixed(1)));
                dailyElongationScores.push(parseFloat(elongScore.toFixed(1))); // And here

                const combinedScore = (magScore + elongScore) / 2;
                dailyCombinedScores.push(parseFloat(combinedScore.toFixed(1)));
            }
            modeData.planets[planetId] = {
                mockMagnitudes: mockMagnitudes, mockElongations: mockElongations,
                dailyMagnitudeScores: dailyMagnitudeScores, dailyElongationScores: dailyElongationScores,
                dailyScores: dailyCombinedScores 
            };
        });
        modeData.status = 'ok';
        console.log("[LOG] calculateObservabilityData END - Status OK, data:", JSON.parse(JSON.stringify(modeData.planets)));
    }


    // --- ORIGINAL API Fetching and Data Processing (RESTORED and integrated with new magnitude parsing) ---
    async function fetchAndUpdateLiveData() {
        console.log("[API] Attempting to fetch live data...");
        hasLoggedApiStructure = false; // Reset for each fetch attempt
        // Set status to pending for data sets that require live API data
        if (displayData.apparentEarth.requires_live) { displayData.apparentEarth.status = 'pending'; displayData.apparentEarth.error = null; }
        if (displayData.distEarth.requires_live) { displayData.distEarth.status = 'pending'; displayData.distEarth.error = null; }
        // Observability is also recalculated, so set to pending
        displayData.observability.status = 'pending'; displayData.observability.error = null;

        customDistanceStatus = 'pending'; customDistanceError = null;

        // Show loading overlays
        if (displayData[currentSizeMode]?.requires_live) showLoading('size', true);
        if (displayData[currentDistMode]?.requires_live || currentDistMode === 'custom') showLoading('dist', true);
        showLoading('obs', true); // Show loading for observability chart

        apiFetchError = null;
        try {
            console.log("[API LOG] Fetching from /.netlify/functions/planetDashboard");
            const response = await fetch('/.netlify/functions/planetDashboard');
            console.log(`[API LOG] API Response Status: ${response.status}`);

            if (!response.ok) {
                const errorText = await response.text();
                console.error(`[API ERROR] API Fetch Error ${response.status}: ${errorText}`);
                throw new Error(`API Error ${response.status}: ${errorText}`);
            }
            const rawData = await response.json();
            // console.log("[API LOG] Raw API Data Received (first 500 chars):", JSON.stringify(rawData).substring(0,500));

            if (rawData?.data?.table?.rows) {
                liveApiData = {}; // Reset liveApiData for current day
                let processingOk = true; // From original code
                console.log("[API LOG] Processing rows from API data...");

                rawData.data.table.rows.forEach(row => {
                    const id = row.entry?.id?.toLowerCase();
                    const cell = row.cells?.[0]; // Data is in the first cell
                    if (!id || !cell) {
                        console.warn(`[API WARN] Skipping row: Missing id or cell. Row: ${JSON.stringify(row)}`);
                        return;
                    }
                    // console.log(`[API LOG] Processing cell for ${id}: ${JSON.stringify(cell)}`);

                    const distStr = cell.distance?.fromEarth?.au;
                    const raHoursStr = cell.position?.equatorial?.rightAscension?.hours;
                    const decDegStr = cell.position?.equatorial?.declination?.degrees;
                    
                    // Magnitude is now expected on cell.apparentMagnitude (set by Netlify function)
                    const magnitude = cell.apparentMagnitude; 
                    // console.log(`[API LOG] For ${id}, mag from cell: ${magnitude}`);


                    const distNum = parseFloat(distStr);
                    const raHoursNum = parseFloat(raHoursStr);
                    const decDegNum = parseFloat(decDegStr);

                    if (isNaN(distNum) || isNaN(raHoursNum) || isNaN(decDegNum)) {
                        console.warn(`[API WARN] Invalid numeric data for ${id}. Dist: ${distStr}, RA: ${raHoursStr}, Dec: ${decDegStr}`);
                        processingOk = false; // From original code
                        liveApiData[id] = { id: id, name: row.entry?.name, distEarth: NaN, raRad: NaN, decRad: NaN, magnitude: null };
                    } else {
                        liveApiData[id] = {
                            id: id, name: row.entry?.name,
                            distEarth: distNum,
                            raRad: toRadians(raHoursNum * 15),
                            decRad: toRadians(decDegNum),
                            magnitude: (typeof magnitude === 'number' && !isNaN(magnitude)) ? magnitude : null
                        };
                    }
                    // console.log(`[API LOG] Processed liveApiData for ${id}:`, JSON.parse(JSON.stringify(liveApiData[id])));
                });

                if (!liveApiData.earth) { // Original check
                    liveApiData.earth = { id: 'earth', name: 'Earth', distEarth: 0, raRad: 0, decRad: 0, magnitude: null };
                    console.log("[API LOG] Manually added Earth data to liveApiData.");
                }
                // console.log("[API LOG] Processed live data map (coords in rad):", JSON.parse(JSON.stringify(liveApiData)));
                apiFetchError = null;

                // Recalculate all data sets (original + new)
                console.log("[API LOG] Recalculating all data sets after API fetch...");
                calculateTrueSizeData();
                calculateApparentSunData();
                calculateDistSunData();
                calculateApparentEarthData(liveApiData);
                calculateDistEarthData(liveApiData);
                calculateAllCustomDistData(liveApiData);
                calculateObservabilityData(); // New observability calculation
                console.log("[API LOG] All data sets recalculated.");

            } else {
                console.error("[API ERROR] Unexpected API data structure received:", rawData);
                throw new Error("API returned unexpected data structure");
            }
        } catch (error) {
            console.error("[API CRITICAL ERROR] in fetchAndUpdateLiveData:", error);
            apiFetchError = error.message; liveApiData = null;
            // Original error handling for displayData
            if(displayData.apparentEarth.requires_live) { displayData.apparentEarth.status = 'error'; displayData.apparentEarth.error = apiFetchError; }
            if(displayData.distEarth.requires_live) { displayData.distEarth.status = 'error'; displayData.distEarth.error = apiFetchError; }
            // Add for observability
            displayData.observability.status = 'error'; displayData.observability.error = `Failed to update: ${apiFetchError}`;
            customDistanceStatus = 'error'; customDistanceError = apiFetchError;
            
            // Show errors in UI (original approach)
            showError('size', `Failed to fetch data: ${apiFetchError}`);
            showError('dist', `Failed to fetch data: ${apiFetchError}`);
            showError('obs', `Failed to fetch/process data: ${apiFetchError}`);

        } finally {
            console.log("[API LOG] fetchAndUpdateLiveData finally block. Drawing all charts.");
            showLoading('size', false); showLoading('dist', false); showLoading('obs', false);
            drawSizeGrid();
            drawDistanceChart();
            drawObservabilityChart(); // Draw new chart
            drawObservabilityDebugData(); // Draw debug data
            console.log("[API LOG] Scheduling next API refresh.");
            clearTimeout(apiRefreshTimer); apiRefreshTimer = setTimeout(fetchAndUpdateLiveData, REFRESH_INTERVAL_MS);
        }
        console.log("[API LOG] fetchAndUpdateLiveData END");
    }


    // --- UI Update Functions ---
    // ... (showLoading, showError - unchanged from previous response)
    // ... (drawSizeGrid, drawDistanceChart, drawObservabilityChart, drawObservabilityDebugData - unchanged from previous response)
    // ... (Event Handlers & UI Logic - unchanged from previous response)
    // ... (initializeDashboard, toggleModal - unchanged from previous response)

    // --- UI Update Functions (Keep as they were - fully expanded) ---
    function showLoading(panelType, isLoading) {
        // console.log(`[LOG] showLoading for ${panelType}: ${isLoading}`);
        let element;
        if (panelType === 'size') element = sizeLoading;
        else if (panelType === 'dist') element = distLoading;
        else if (panelType === 'obs') element = obsLoading;
        if (element) element.style.display = isLoading ? 'flex' : 'none';
    }
    function showError(panelType, message) {
        console.log(`[LOG] showError for ${panelType}: "${message}"`);
        let element; let displayMessage = message;
        if (panelType === 'size') {
            element = sizeError;
            if (displayData[currentSizeMode]?.status === 'error') displayMessage = displayData[currentSizeMode].error || message;
        } else if (panelType === 'dist') {
            element = distError;
            if (currentDistMode === 'custom' && customDistanceStatus === 'error') displayMessage = customDistanceError || message;
            else if (displayData[currentDistMode]?.status === 'error') displayMessage = displayData[currentDistMode].error || message;
        } else if (panelType === 'obs') {
            element = obsError;
            if (displayData.observability?.status === 'error') displayMessage = displayData.observability.error || message;
        }
        if (element) { element.textContent = displayMessage || ''; element.style.display = displayMessage ? 'flex' : 'none'; }
    }

    function drawSizeGrid() {
        console.log(`[Draw] Drawing Size Grid for mode: ${currentSizeMode}`);
        const modeData = displayData[currentSizeMode];
        if (!modeData || (modeData.status !== 'ok' && modeData.status !== 'partial')) {
            showLoading('size', modeData?.status === 'pending');
            showError('size', modeData?.status === 'error' ? (modeData.error || 'Failed to load size data.') : null);
            if(sizeGrid) sizeGrid.innerHTML = ''; console.log("[Draw] drawSizeGrid END - No data to draw."); return;
        }
        showLoading('size', false);
        showError('size', modeData.status === 'partial' ? (modeData.error || 'Note: Some planet size data may be missing.') : null);
        const planetDataMap = modeData.planets; if(!sizeGrid) {console.error("[ERROR] sizeGrid DOM element not found in drawSizeGrid"); return;} sizeGrid.innerHTML = '';
        const planetsToShow = (currentSizeMode === 'apparentEarth') ? OBSERVABLE_PLANETS : PLANET_ORDER; 
        planetsToShow.forEach(p => {
            const planetData = planetDataMap[p]; const slot = document.createElement('div'); slot.className = 'planet-slot'; slot.id = `slot-${p}`;
            if (p === 'earth' && currentSizeMode === 'apparentEarth') return;
            if (planetData && typeof planetData.px === 'number') {
                const imgContainer = document.createElement('div'); imgContainer.className = 'planet-image-container';
                const img = document.createElement('img'); img.src = `planets/${p}.png`; img.alt = p;
                img.onerror = function() { this.style.display='none'; slot.querySelector('.size-label').textContent = 'Image N/A';};
                img.style.height = `${planetData.px}px`; img.style.width = 'auto';
                imgContainer.appendChild(img);
                const label = document.createElement('div'); label.className = 'size-label'; label.textContent = planetData.label || 'N/A';
                slot.appendChild(imgContainer); slot.appendChild(label);
            } else {
                slot.innerHTML = `<div class="planet-image-container" style="color:var(--color-text-secondary); display:flex; align-items:center; justify-content:center; font-size: var(--cell); ">?</div><div class="size-label">No data for ${p}</div>`;
            }
            sizeGrid.appendChild(slot);
        });
        console.log("[Draw] Finished drawing size grid.");
    }

    function drawDistanceChart() {
        console.log(`[Draw] Drawing Distance Chart for mode: ${currentDistMode}`);
        if (!distAnchor || !distPlanetsContainer) { console.error("[Draw Dist] Core elements not found!"); return; }
        distPlanetsContainer.innerHTML = ''; distAnchor.style.display = 'none'; 
        showLoading('dist', false); showError('dist', null); 

        let planetDataMap; let anchorId = 'earth'; let isSunMode = false; let isCustomMode = currentDistMode === 'custom';
        console.log(`[Draw Dist] Mode: ${currentDistMode}, Custom anchor: ${selectedCustomPlanet}`);

        if (isCustomMode) {
            if (!selectedCustomPlanet) { showError('dist', 'Please select a custom anchor planet.'); console.log("[Draw Dist] END - No custom anchor."); return; }
            if (customDistanceStatus === 'pending') { showLoading('dist', true); console.log("[Draw Dist] END - Custom data pending."); return; }
            if (customDistanceStatus === 'error' || !customDistanceData[selectedCustomPlanet] || customDistanceData[selectedCustomPlanet].status === 'error') {
                showError('dist', customDistanceData[selectedCustomPlanet]?.error || customDistanceError || 'Could not calculate custom distances.'); console.log("[Draw Dist] END - Custom data error."); return;
            }
            if (customDistanceData[selectedCustomPlanet].status === 'partial') {
                showError('dist', customDistanceData[selectedCustomPlanet].error || 'Could not calculate some distances for the selected anchor.');
            }
            planetDataMap = customDistanceData[selectedCustomPlanet].planets;
            if (!planetDataMap) { showError('dist', `No distance data available for ${selectedCustomPlanet}.`); console.log("[Draw Dist] END - No planetDataMap for custom."); return; }
            anchorId = selectedCustomPlanet;
        } else { 
            const modeData = displayData[currentDistMode];
            if (!modeData || (modeData.status !== 'ok' && modeData.status !== 'partial')) {
                 showLoading('dist', modeData?.status === 'pending');
                 showError('dist', modeData?.status === 'error' ? (modeData.error || 'Failed to load distance data.') : null);
                 console.log("[Draw Dist] END - Standard mode data not OK."); return;
            }
            showError('dist', modeData.status === 'partial' ? (modeData.error || 'Note: Some planet distance data may be missing.') : null);
            planetDataMap = modeData.planets;
            isSunMode = currentDistMode === 'distSun';
            anchorId = isSunMode ? 'sun' : 'earth';
        }
        console.log(`[Draw Dist] Anchor for distance chart: ${anchorId}`);

        distAnchor.style.display = 'block'; distAnchor.src = `planets/${anchorId}.png`;
        distAnchor.onerror = function() { this.style.display='none'; console.warn(`[WARN] Failed to load anchor image: planets/${anchorId}.png`);}; 

        let anchorVisH;
        if (anchorId === 'sun') {
            const sunDiameter = PLANET_META.sun; const jupiterDiameter = PLANET_META.jupiter;
            anchorVisH = (sunDiameter && jupiterDiameter) ? (sunDiameter / jupiterDiameter) * (getCssVariableValue('--dist-planet-base-height-pct') || BASE_PLANET_VISUAL_HEIGHT_PCT)
                                           : (getCssVariableValue('--dist-planet-base-height-pct') || BASE_PLANET_VISUAL_HEIGHT_PCT) * 5; 
            distAnchor.style.height = `${anchorVisH}%`; distAnchor.style.maxHeight = 'none'; 
            distAnchor.style.transform = 'translate(-100%, -50%)'; 
        } else {
            anchorVisH = calculateVisualHeightPct(anchorId);
            distAnchor.style.height = `${anchorVisH}%`;
            distAnchor.style.maxHeight = `${getCssVariableValue('--dist-planet-max-height-pct') || MAX_PLANET_VISUAL_HEIGHT_PCT}%`;
            distAnchor.style.transform = 'translate(-50%, -50%)'; 
        }

        let targets = []; let maxDist = 0;
        if (isCustomMode) {
            const customPlanets = customDistanceData[selectedCustomPlanet].planets;
            PLANET_ORDER.forEach(p => {
                if (p === selectedCustomPlanet) return; 
                const planetInfo = customPlanets[p];
                if (planetInfo && typeof planetInfo.dist === 'number' && !isNaN(planetInfo.dist) && planetInfo.dist > 0) {
                    targets.push({ id: p, dist: planetInfo.dist, label: planetInfo.label, visH: planetInfo.visH });
                    if (planetInfo.dist > maxDist) maxDist = planetInfo.dist;
                } else {
                     console.warn(`[WARN] Invalid custom distance data for target ${p} from ${selectedCustomPlanet}`);
                }
            });
        } else { 
            const standardPlanets = isSunMode ? PLANET_ORDER : PLANET_ORDER.filter(p => p !== 'earth'); 
            standardPlanets.forEach(p => {
                const data = planetDataMap[p];
                if (data && typeof data.pos === 'number') { 
                    let distValue;
                    if (currentDistMode === 'distEarth' && liveApiData?.[p]) distValue = liveApiData[p].distEarth;
                    else if (currentDistMode === 'distSun') distValue = PLANET_SMA[p];

                    if (typeof distValue === 'number' && !isNaN(distValue) && distValue >= 0) { 
                        targets.push({ id: p, dist: distValue, label: data.label, visH: data.visH });
                        if (distValue > maxDist) maxDist = distValue;
                    } else {
                         console.warn(`[WARN] Invalid standard distance data for target ${p}`);
                    }
                }
            });
        }

        if (maxDist <= 0 && targets.length > 0) { 
            console.warn("[WARN] maxDist is 0 or less for distance chart, setting to 1 for scaling.");
            maxDist = 1; 
        } else if (targets.length === 0) {
            console.log("[Draw Dist] No target planets to display for distance chart.");
            return;
        }
        console.log(`[Draw Dist] Max distance for scaling: ${maxDist} AU. Targets:`, targets.length);


        targets.forEach(target => {
            const p = target.id; const distanceAu = target.dist;
            const positionPct = (maxDist > 0) ? (distanceAu / maxDist) * 100 : 0; 
            const labelText = target.label;
            const visualHeightPct = target.visH || calculateVisualHeightPct(p); 

            const img = document.createElement('img'); img.src = `planets/${p}.png`; img.alt = p; img.className = 'dist-planet-img';
            img.onerror = function() { this.style.display='none'; console.warn(`[WARN] Failed to load planet image: planets/${p}.png`);};
            img.style.left = `${positionPct}%`; img.style.height = `${visualHeightPct}%`;
            distPlanetsContainer.appendChild(img);

            const label = document.createElement('div'); label.className = 'dist-label';
            const labelNudgeX = (isSunMode && PLANET_ORDER.indexOf(p) < 4 && positionPct < 20) ? 15 : 0; 
            const labelNudgeY = (isSunMode && PLANET_ORDER.indexOf(p) < 2 && positionPct < 10) ? -10 : 0; 
            label.style.left = `calc(${positionPct}% + ${labelNudgeX}px)`;
            label.style.top = `calc(50% - 40px + ${labelNudgeY}px)`; 
            label.textContent = labelText;
            distPlanetsContainer.appendChild(label);
        });
        console.log("[Draw] Finished drawing distance chart.");
    }

    function drawObservabilityChart() {
        console.log("[Draw Obs] Drawing Observability Chart...");
        if (!obsChartContainer) { console.error("[Draw Obs] Chart container not found!"); return; }
        const modeData = displayData.observability;

        if (!modeData || (modeData.status !== 'ok' && modeData.status !== 'partial')) {
            showLoading('obs', modeData?.status === 'pending');
            showError('obs', modeData?.status === 'error' ? (modeData.error || 'Failed to load observability data.') : null);
            obsChartContainer.innerHTML = ''; console.log("[Draw Obs] END - No data to draw.");
            return;
        }
        showLoading('obs', false);
        showError('obs', modeData.status === 'partial' ? (modeData.error || 'Note: Some observability data may be incomplete.') : null);
        obsChartContainer.innerHTML = ''; 

        OBSERVABLE_PLANETS.forEach(planetId => {
            const planetObsData = modeData.planets[planetId];
            if (!planetObsData || !planetObsData.dailyScores) {
                console.warn(`[Draw Obs] No observability scores data for ${planetId}`);
                return; 
            }

            const row = document.createElement('div'); row.className = 'observability-planet-row';
            const label = document.createElement('div'); label.className = 'observability-planet-label'; label.textContent = planetId;
            row.appendChild(label);
            const barContainer = document.createElement('div'); barContainer.className = 'observability-bar-container';
            const bar = document.createElement('div'); bar.className = 'observability-bar';

            let gradientCss = 'linear-gradient(to right';
            const numDays = planetObsData.dailyScores.length;
            if (numDays === 0) {
                gradientCss += `, var(--color-medium-grey) 0%, var(--color-medium-grey) 100%`; 
            } else {
                planetObsData.dailyScores.forEach((score, dayIndex) => {
                    const color = getObservabilityColor(score);
                    const startPercent = (dayIndex / numDays) * 100;
                    const endPercent = ((dayIndex + 1) / numDays) * 100;
                    gradientCss += `, ${color} ${startPercent.toFixed(2)}%, ${color} ${endPercent.toFixed(2)}%`;
                });
            }
            gradientCss += ')';
            bar.style.background = gradientCss;

            barContainer.appendChild(bar); row.appendChild(barContainer); obsChartContainer.appendChild(row);
        });
        console.log("[Draw Obs] Finished drawing observability chart.");
    }

    function drawObservabilityDebugData() {
        console.log("[Draw Debug] Drawing Observability Debug Data...");
        if (!obsDebugContainer) { console.error("[Draw Debug] Debug container not found!"); return; }
        const obsData = displayData.observability;
        if (!obsData || obsData.status !== 'ok' || !obsData.planets) {
            obsDebugContainer.innerHTML = '<p>Observability detailed data not available or not yet calculated.</p>';
            console.log("[Draw Debug] END - No data available.");
            return;
        }
        obsDebugContainer.innerHTML = '<h3>Observability Calculation Details (Mock Data)</h3>';

        OBSERVABLE_PLANETS.forEach(planetId => {
            const planetData = obsData.planets[planetId];
            if (!planetData) {
                console.warn(`[Draw Debug] No debug data for planet ${planetId}`);
                return;
            }

            const planetDetails = document.createElement('details');
            const planetSummary = document.createElement('summary');
            planetSummary.textContent = planetId;
            planetDetails.appendChild(planetSummary);

            const dataTypes = [
                { name: 'Mock Magnitudes', dataArray: planetData.mockMagnitudes, unit: 'mag' },
                { name: 'Mock Elongations', dataArray: planetData.mockElongations, unit: '°' },
                { name: 'Magnitude Scores', dataArray: planetData.dailyMagnitudeScores, unit: '/10' },
                { name: 'Elongation Scores', dataArray: planetData.dailyElongationScores, unit: '/10' },
                { name: 'Combined Scores (Bar Data)', dataArray: planetData.dailyScores, unit: '/10' }
            ];

            dataTypes.forEach(type => {
                if (type.dataArray && type.dataArray.length > 0) {
                    const typeDetails = document.createElement('details'); 
                    const typeSummary = document.createElement('summary');
                    typeSummary.textContent = type.name;
                    typeDetails.appendChild(typeSummary);

                    const listContainer = document.createElement('div');
                    listContainer.className = 'debug-list-container'; 
                    type.dataArray.forEach((value, dayIndex) => {
                        const dayEntry = document.createElement('div');
                        dayEntry.className = 'debug-day-entry';
                        dayEntry.innerHTML = `<span class="day-num">Day ${dayIndex + 1}:</span> <span class="data-val">${value !== null && value !== undefined ? value : 'N/A'}</span> <span class="unit">${type.unit}</span>`;
                        listContainer.appendChild(dayEntry);
                    });
                    typeDetails.appendChild(listContainer);
                    planetDetails.appendChild(typeDetails);
                } else {
                    // console.log(`[Draw Debug] No data for type "${type.name}" for planet ${planetId}`);
                }
            });
            obsDebugContainer.appendChild(planetDetails);
        });
        console.log("[Draw Debug] Finished drawing observability debug data.");
    }


    // --- Event Handlers & UI Logic ---
    function toggleCustomDropdown(forceClose = false) { console.log(`[Event] toggleCustomDropdown(forceClose: ${forceClose})`); if(!customDistDropdown||!customDistButton)return; const sS=!customDistDropdown.classList.contains('show')&&!forceClose; customDistDropdown.classList.toggle('show',sS); customDistButton.classList.toggle('open',sS); if(sS)updateDropdownHighlight(); }
    function updateDropdownHighlight() { console.log("[Event] updateDropdownHighlight"); if(!customDistList)return; customDistList.querySelectorAll('li').forEach(li=>li.classList.toggle('selected',li.dataset.planet===selectedCustomPlanet)); }
    function selectCustomPlanet(planetId) { console.log(`[Event] selectCustomPlanet: ${planetId}`); selectedCustomPlanet=planetId; currentDistMode='custom'; if(customDistButtonText)customDistButtonText.textContent=planetId.charAt(0).toUpperCase()+planetId.slice(1); document.querySelectorAll('#dist-mode-switch button').forEach(b=>b.classList.remove('active')); if(customDistButton)customDistButton.classList.add('active'); toggleCustomDropdown(true); drawDistanceChart(); }
    function populateCustomDropdown() { console.log("[Event] populateCustomDropdown"); if(!customDistList)return; customDistList.innerHTML=''; OBSERVABLE_PLANETS.forEach(p=>{const li=document.createElement('li');li.textContent=p.charAt(0).toUpperCase()+p.slice(1);li.dataset.planet=p;customDistList.appendChild(li);}); }
    document.querySelectorAll('#dist-mode-switch button[data-mode="distSun"],#dist-mode-switch button[data-mode="distEarth"]').forEach(btn=>{btn.addEventListener('click',e=>{const tB=e.currentTarget;if(!tB.disabled&&!tB.classList.contains('active')){console.log(`[Event] Dist mode button clicked: ${tB.dataset.mode}`); const nM=tB.dataset.mode;currentDistMode=nM;selectedCustomPlanet=null;if(customDistButtonText)customDistButtonText.textContent='custom';document.querySelectorAll('#dist-mode-switch button').forEach(b=>b.classList.remove('active'));tB.classList.add('active');if(customDistButton)customDistButton.classList.remove('active');toggleCustomDropdown(true);drawDistanceChart();}});});
    if(customDistButton)customDistButton.addEventListener('click',e=>{console.log("[Event] Custom dist button clicked"); e.stopPropagation();toggleCustomDropdown();});
    if(customDistList)customDistList.addEventListener('click',e=>{if(e.target.tagName==='LI'&&e.target.dataset.planet){console.log(`[Event] Custom dist LI clicked: ${e.target.dataset.planet}`); e.stopPropagation();selectCustomPlanet(e.target.dataset.planet);}});
    document.addEventListener('click',e=>{if(customDistDropdown&&customDistDropdown.classList.contains('show')){if(!customDistButton?.contains(e.target)&&!customDistDropdown.contains(e.target)){console.log("[Event] Click outside custom dropdown detected");toggleCustomDropdown(true);}}});
    document.getElementById('size-mode-switch').addEventListener('click',e=>{if(e.target.tagName==='BUTTON'&&!e.target.disabled&&!e.target.classList.contains('active')){console.log(`[Event] Size mode button clicked: ${e.target.dataset.mode}`); const nM=e.target.dataset.mode;currentSizeMode=nM;e.target.parentNode.querySelectorAll('button').forEach(b=>b.classList.remove('active'));e.target.classList.add('active');drawSizeGrid();}});

    let resizeTimeout;
    window.addEventListener('resize',()=>{ console.log("[Event] Window resize event detected"); clearTimeout(resizeTimeout);resizeTimeout=setTimeout(()=>{ console.log("[Event] Debounced resize handler executing"); BASE_PLANET_VISUAL_HEIGHT_PCT=getCssVariableValue('--dist-planet-base-height-pct')||35;MIN_PLANET_VISUAL_HEIGHT_PCT=getCssVariableValue('--dist-planet-min-height-pct')||5;MAX_PLANET_VISUAL_HEIGHT_PCT=getCssVariableValue('--dist-planet-max-height-pct')||80;calculateTrueSizeData();calculateApparentSunData();calculateDistSunData();calculateObservabilityData();if(liveApiData){calculateApparentEarthData(liveApiData);calculateDistEarthData(liveApiData);calculateAllCustomDistData(liveApiData);}drawSizeGrid();drawDistanceChart();drawObservabilityChart();drawObservabilityDebugData();},250);});

    // --- Initialization ---
    function initializeDashboard() {
        console.log("[LOG] initializeDashboard START");
        const essentialDOM=[sizeGrid,distAnchor,distPlanetsContainer,sizeLoading,sizeError,distLoading,distError,customDistButton,customDistButtonText,customDistDropdown,customDistList,obsSection,obsChartContainer,obsLoading,obsError,obsDebugContainer];
        if(essentialDOM.some(el=>!el)){console.error("[CRITICAL ERROR] Essential DOM elements missing on init.");document.body.innerHTML='<p style="color:var(--color-text-error);padding:50px;text-align:center;font-size:1.2rem;">Error: Page components missing.</p>';return;}
        
        console.log("[LOG] Reading initial CSS variables for JS state.");
        BASE_PLANET_VISUAL_HEIGHT_PCT=getCssVariableValue('--dist-planet-base-height-pct')||35;
        MIN_PLANET_VISUAL_HEIGHT_PCT=getCssVariableValue('--dist-planet-min-height-pct')||5;
        MAX_PLANET_VISUAL_HEIGHT_PCT=getCssVariableValue('--dist-planet-max-height-pct')||80;
        
        populateCustomDropdown();
        console.log("[LOG] Calculating initial data sets (static/mock)...");
        calculateTrueSizeData();calculateApparentSunData();calculateDistSunData();calculateObservabilityData();
        
        sizeGrid.innerHTML=''; PLANET_ORDER.forEach(p=>{const s=document.createElement('div');s.className='planet-slot';s.id=`slot-${p}`;s.innerHTML=`<div class="planet-image-container"></div><div class="size-label"id="lbl-${p}"></div>`;sizeGrid.appendChild(s);});
        
        console.log("[LOG] Performing initial draws...");
        if(displayData[currentSizeMode]?.status==='ok')drawSizeGrid();else showLoading('size',true);
        if(displayData[currentDistMode]?.status==='ok'&&currentDistMode!=='custom')drawDistanceChart();else if(currentDistMode!=='custom')showLoading('dist',true);
        if(displayData.observability?.status==='ok'){drawObservabilityChart();drawObservabilityDebugData();}else showLoading('obs',true);
        
        fetchAndUpdateLiveData();
        console.log("[LOG] initializeDashboard END");
    }
    function toggleModal() { 
        console.log("[LOG] toggleModal called");
        const modal = document.getElementById('modal');
        const backdrop = document.getElementById('modal-backdrop');
        if (!modal || !backdrop) {console.warn("[WARN] Modal or backdrop not found in toggleModal"); return;}
        const isOpen = modal.classList.contains('open');
        modal.classList.toggle('open', !isOpen);
        backdrop.classList.toggle('open', !isOpen);
        document.body.classList.toggle('modal-open', !isOpen); 
    }
    document.addEventListener('DOMContentLoaded', initializeDashboard);
 </script>
 <script src="/scripts.js"></script>
 </body>
</html>