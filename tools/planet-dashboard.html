<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Planets Dashboard – Hansen Space</title>
  <link rel="stylesheet" href="/styles.css">
  <style>
    /* Dashboard-specific CSS variables */
    :root {
      --cell:200px;      
      --gap:50px;        
      --dist-aspect:1000/256; 
      --dist-planet-base-height-pct: 35%; 
      --dist-planet-min-height-pct: 0.1%;  
      --dist-planet-max-height-pct: 80%;  

      --obs-bar-height: 28px;
      --obs-bar-border-radius: 8px;
      --obs-bar-spacing: 18px;
      --obs-label-width: 100px;
    }

    .loading-overlay, .error-overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(30,30,30,0.85); 
      display: flex; justify-content: center; align-items: center;
      text-align: center; z-index: 10; color: var(--color-text-primary);
      font-size: 16px; padding: 20px; pointer-events: none;
      border-radius: 8px; 
    }
    .error-overlay {
      color: var(--color-text-error);
      background: rgba(50,0,0,0.85); 
    }

    .dashboard-panel { 
      background: black; /* REVERTED TO BLACK as per original */
      border-radius:8px; 
      padding:30px 20px;
      position: relative;
      min-height: 150px;
      overflow: hidden;
    }

    #size-grid {
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(var(--cell),1fr));
      grid-auto-rows:var(--cell);
      gap:var(--gap);
      justify-content:center;
      padding-bottom: 30px; 
    }
    .planet-slot {
      position:relative; display:flex; flex-direction: column;
      justify-content:center; align-items:center;
    }
    .planet-image-container {
      flex-grow: 1; display: flex; justify-content: center; align-items: center;
      width: 100%; height: 100%;
    }
    .planet-image-container img {
      max-width: 100%; max-height: 100%; object-fit: contain;
    }
    .size-label {
      position:absolute; bottom:-26px; left:50%; transform:translateX(-50%);
      font-size:14px; color: var(--color-text-secondary); white-space:nowrap;
    }

    .panel-distance { 
        padding-top:30px; padding-bottom:30px
    }
    #dist-box {
      width:100%; max-width:none; margin:0 auto;
      aspect-ratio: var(--dist-aspect); position:relative; min-height: 150px;
      overflow: visible; 
    }
    .dist-track { position:absolute; top:0; left:0; width:100%; height:100%; }
    .dist-track::before { 
      content:""; position:absolute; top:50%;
      left: 5%; width: 90%; height:2px;
      background: var(--color-light-grey-borders-dividers); transform:translateY(-50%);
     }
    .anchor { 
      position:absolute; left:0; top:50%; z-index: 5; width: auto; max-height: none;
     }
    #dist-planets { 
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      padding: 0; color: var(--color-text-secondary); font-size: 12px;
      line-height: 1.5; font-family: monospace; 
      overflow: visible;
    }
    #dist-planets .dist-planet-img {
      position:absolute; top:50%; transform:translate(-50%, -50%); width:auto;
      min-height: var(--dist-planet-min-height-pct); max-height: var(--dist-planet-max-height-pct);
      z-index: 4; object-fit: contain;
     }
    #dist-planets .dist-label {
      position:absolute; top:calc(50% - 40px); color: var(--color-text-primary); white-space:nowrap;
      transform-origin:top left; transform:rotate(-40deg);
      font-size: clamp(10px, 1.2vw, 14px); z-index: 6;
     }

    #observability-section {
        padding-top: 10px; padding-bottom: 10px;
    }
    #observability-content-area { 
        position: relative; 
        min-height: 100px; 
    }
    #observability-chart {
        padding: 10px 0; 
    }
    .observability-planet-row {
        display: flex;
        align-items: center;
        margin-bottom: var(--obs-bar-spacing);
    }
    .observability-planet-label {
        width: var(--obs-label-width);
        padding-right: 15px;
        text-align: right;
        font-size: 15px; 
        font-weight: 600; 
        color: var(--color-text-primary); 
        text-transform: capitalize;
        flex-shrink: 0; 
    }
    .observability-bar-container {
        flex-grow: 1;
        height: var(--obs-bar-height);
        position: relative; 
    }
    .observability-bar {
        width: 100%;
        height: 100%;
        border-radius: var(--obs-bar-border-radius);
        background: var(--color-light-grey-borders-dividers); 
        box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
        cursor: crosshair; 
    }
    #observability-tooltip {
        position: fixed; 
        background-color: rgba(10, 10, 10, 0.92); 
        color: var(--color-text-primary);
        border: 1px solid var(--color-light-grey-borders-dividers);
        padding: 8px 12px; 
        border-radius: 6px;
        font-size: 12px; 
        font-family: var(--font-primary); 
        line-height: 1.6; 
        white-space: nowrap;
        z-index: 10010; 
        pointer-events: none; 
        display: none; 
        box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        /* transform removed for now, JS will handle all positioning */
    }
    #observability-tooltip div { 
        margin-bottom: 2px; 
    }
     #observability-tooltip div:last-child {
        margin-bottom: 0;
    }


    #observability-content-area .loading-overlay,
    #observability-content-area .error-overlay {
        border-radius: var(--obs-bar-border-radius); 
        background: rgba(46, 46, 46, 0.85); 
    }

    @media (max-width: 850px) {
      :root { 
        --cell: calc(200px * 0.55); --gap: calc(50px * 0.6);
        --dist-planet-base-height-pct: 18%; --dist-planet-max-height-pct: 65%;
        --obs-label-width: 85px; --obs-bar-height: 26px;
      }
      .size-label { font-size:12px }
      #dist-planets .dist-label { font-size: clamp(9px, 1.3vw, 12px); top:calc(50% - 30px); }
      .observability-planet-label { font-size: 14px; }
      .dashboard-panel { padding: 20px 15px; }
      #size-grid { padding-bottom: 20px; }
    }
    @media (max-width: 480px) {
      :root { 
          --cell: calc(200px * 0.45); --gap: calc(50px * 0.5);
          --dist-planet-base-height-pct: 15%; --dist-planet-max-height-pct: 55%;
          --obs-label-width: auto; --obs-bar-height: 24px; --obs-bar-spacing: 16px;
      }
      .size-label { font-size:11px; bottom: -22px; }
      #dist-planets .dist-label { font-size: clamp(8px, 1.5vw, 10px); top:calc(50% - 25px); }
      .observability-planet-row { flex-direction: column; align-items: stretch; }
      .observability-planet-label { text-align: left; width: 100%; margin-bottom: 6px; padding-right: 0;}
      .observability-bar-container { width: 100%; }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-inner-container content-limiter">
      <a class="brand" href="/index.html">
        <img src="/images/logo.png" alt="Hansen Space Logo" onerror="this.src='https://placehold.co/200x50/1c1c1c/FFFFFF?text=Hansen+Space'; this.onerror=null;" />
      </a>
      <nav>
        <ul>
          <li><a href="/index.html">Home</a></li>
          <li><a href="/myjourney.html">My Journey</a></li>
          <li><a href="/photography.html">Photography</a></li>
          <li><a href="/articles">Articles</a></li>
          <li><a href="/tools.html">Tools</a></li>
          <li><a href="/contact.html" class="active">Contact</a></li>
        </ul>
      </nav>
      <div class="menu-icon" onclick="toggleModal()">☰</div>
    </div>
  </header>

  <div class="modal-backdrop" id="modal-backdrop" onclick="toggleModal()"></div>
  <div class="modal" id="modal">
    <a href="/index.html">Home</a>
    <a href="/myjourney.html">My Journey</a>
    <a href="/photography.html">Photography</a>
    <a href="/articles">Articles</a>
    <a href="/tools.html">Tools</a>
    <a href="/contact.html" class="active">Contact</a>
  </div>
  <main class="page-main-content-area content-limiter">

    <div class="intro-block"> <h1 class="intro-block__title">PLANET DASHBOARD</h1>
      <p class="intro-block__text">This page shows useful information for observing the planets from Earth and understanding the live status of the Solar System. Planets' polar diameters are used for all angular size, diameter, and visual scaling calculations. All data is current.</p>
    </div>

    <div class="content-divider"></div> <section>
      <div class="section-heading-block"> <h2 class="section-heading-block__title">SIZE</h2>
        <p class="section-heading-block__text">Compare the planets by their actual physical (polar) diameters, or see how large they appear from Earth or the Sun based on their current distance and angular size.</p>
      </div>
      <div class="pill-switch" id="size-mode-switch">
        <button data-mode="trueSize">true size</button>
        <button data-mode="apparentEarth" class="active">apparent size (from Earth)</button>
        <button data-mode="apparentSun">apparent size (from Sun)</button>
      </div>
      <div class="dashboard-panel" id="size-panel">
        <div id="size-grid"></div>
        <div class="loading-overlay" id="size-loading" style="display: none;">Loading Size Data...</div>
        <div class="error-overlay" id="size-error" style="display: none;"></div>
      </div>
    </section>

    <div class="content-divider"></div>

    <section>
      <div class="section-heading-block">
        <h2 class="section-heading-block__title">DISTANCE</h2>
        <p class="section-heading-block__text">Visualize the relative distances of the planets from the Sun, Earth, or any other planet you choose as an anchor point. Distances are updated live.</p>
      </div>
      <div class="pill-switch" id="dist-mode-switch">
        <button data-mode="distSun">from Sun</button>
        <button data-mode="distEarth" class="active">from Earth</button>
        <div class="custom-select-container">
          <button id="custom-dist-button" class="custom-select-button" data-mode="custom">
            <span id="custom-dist-button-text">custom</span>
            <span class="arrow"></span>
          </button>
          <div class="custom-dropdown" id="custom-dist-dropdown">
            <ul id="custom-dist-list"></ul>
          </div>
        </div>
      </div>
      <div class="dashboard-panel panel-distance" id="dist-panel">
        <div id="dist-box">
          <div class="dist-track">
            <img id="dist-anchor" class="anchor" src="planets/earth.png" alt="anchor" onerror="this.src='https://placehold.co/50x50/1c1c1c/a0a0a0?text=Anchor&font=monospace'; this.onerror=null;">
            <div id="dist-planets"></div>
          </div>
        </div>
        <div class="loading-overlay" id="dist-loading" style="display: none;">Loading Distance Data...</div>
        <div class="error-overlay" id="dist-error" style="display: none;"></div>
      </div>
    </section>

    <div class="content-divider"></div>

    <section id="observability-section">
      <div class="section-heading-block">
        <h2 class="section-heading-block__title">IN THE SKY <span style="font-size: 0.6em; color: var(--color-text-secondary); font-weight: 400;">(Next 365 Days, Daily Steps)</span></h2>
        <p class="section-heading-block__text">Predicted viewing favorability for each planet over the coming year, sampled daily. Brighter colors (towards green) indicate better chances to observe, based on a combined score of apparent magnitude and elongation from the Sun. Darker (towards red) means less favorable. Hover over bars for details.</p>
      </div>
      <div id="observability-content-area">
        <div id="observability-chart"></div>
        <div class="loading-overlay" id="obs-loading" style="display: none;">Loading Observability Data...</div>
        <div class="error-overlay" id="obs-error" style="display: none;"></div>
      </div>
      <div id="observability-tooltip"></div> 
    </section>

  </main>

  <footer> <div class="footer-inner-container content-limiter">
      <div class="social-links">
        <a href="#"><img src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/youtube.svg" alt="YouTube"></a>
        <a href="#"><img src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/instagram.svg" alt="Instagram"></a>
        <a href="#"><img src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/tiktok.svg" alt="TikTok"></a>
      </div>
      <p>© <span id="year"></span> Hansen Space. All Rights Reserved.</p>
    </div>
    <script>document.getElementById('year').textContent = new Date().getFullYear();</script>
  </footer>

 <script>
    // --- Static Data ---
    const PLANET_META = { mercury: 4877, venus: 12104, earth: 12714, mars: 6752, jupiter: 133708, saturn: 108728, uranus: 49946, neptune: 48682, sun: 1392700 };
    const PLANET_SMA = { mercury: 0.387, venus: 0.723, earth: 1, mars: 1.524, jupiter: 5.203, saturn: 9.537, uranus: 19.191, neptune: 30.068 };
    const PLANET_ORDER = ["mercury", "venus", "earth", "mars", "jupiter", "saturn", "uranus", "neptune"];
    const OBSERVABLE_PLANETS = ["mercury", "venus", "mars", "jupiter", "saturn", "uranus", "neptune"];
    const AU_KM = 149597870.7;
    const REFRESH_INTERVAL_MS = 15 * 60 * 1000; 
    const OBSERVABILITY_DAY_STEP = 1; 

    const OBSERVABILITY_COLORS = ["#FF0000","#FF0500","#FF0A00","#FF0F00","#FF1400","#FF1900","#FF1E00","#FF2300","#FF2800","#FF2D00","#FF3200","#FF3700","#FF3C00","#FF4100","#FF4600","#FF4B00","#FF5000","#FF5500","#FF5A00","#FF5F00","#FF6400","#FF6900","#FF6E00","#FF7300","#FF7800","#FF7D00","#FF8200","#FF8700","#FF8C00","#FF9100","#FF9600","#FF9B00","#FFA000","#FFA500","#FFA800","#FFAA00","#FFAD00","#FFB000","#FFB300","#FFB500","#FFB800","#FFBB00","#FFBE00","#FFC000","#FFC300","#FFC600","#FFC800","#FFCB00","#FFCE00","#FFD100","#FFD300","#FFD600","#FFD900","#FFDC00","#FFDE00","#FFE100","#FFE400","#FFE600","#FFE900","#FFEC00","#FFEF00","#FFF100","#FFF400","#FFF700","#FFFA00","#FFFC00","#FFFF00","#F8FF00","#F0FF00","#E8FF00","#E1FF00","#DAFF00","#D2FF00","#CBFF00","#C3FF00","#BCFF00","#B4FF00","#ACFF00","#A5FF00","#9EFF00","#96FF00","#8EFF00","#87FF00","#80FF00","#78FF00","#70FF00","#69FF00","#62FF00","#5AFF00","#52FF00","#4BFF00","#43FF00","#3CFF00","#35FF00","#2DFF00","#26FF00","#1EFF00","#17FF00","#0FFF00","#08FF00","#00FF00"];

    // --- Helper Functions & State ---
    function getCssVariableValue(varName) { const value = getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); const floatVal = parseFloat(value); return floatVal || 0; }
    function getTargetMaxPxSize() { const cellElement = document.getElementById('size-grid') || document.documentElement; const computedCellStyle = getComputedStyle(cellElement); let cellBaseSize = parseFloat(computedCellStyle.getPropertyValue('--cell')); if (isNaN(cellBaseSize) || cellBaseSize <=0) { const rootStyle = getComputedStyle(document.documentElement); const rawCellVar = rootStyle.getPropertyValue('--cell').trim(); if (rawCellVar && rawCellVar.includes('px')) { cellBaseSize = parseFloat(rawCellVar); } if (isNaN(cellBaseSize) || cellBaseSize <=0) { cellBaseSize = 190; } } return Math.max(60, cellBaseSize * 0.5); }
    let BASE_PLANET_VISUAL_HEIGHT_PCT = 35; let MIN_PLANET_VISUAL_HEIGHT_PCT = 5;  let MAX_PLANET_VISUAL_HEIGHT_PCT = 80; 
    let currentSizeMode = 'apparentEarth'; let currentDistMode = 'distEarth'; let selectedCustomPlanet = null;
    let liveApiData = null; 
    let observabilityForecastData = null; 
    let apiFetchError = null; let apiRefreshTimer = null; let hasLoggedApiStructure = false; 

    const displayData = {
        trueSize: { planets: {}, requires_live: false, status: 'pending', error: null },
        apparentEarth: { planets: {}, requires_live: true, status: 'pending', error: null },
        apparentSun: { planets: {}, requires_live: false, status: 'pending', error: null },
        distSun: { planets: {}, requires_live: false, status: 'pending', error: null },
        distEarth: { planets: {}, requires_live: true, status: 'pending', error: null },
        observability: { planets: {}, status: 'pending', error: null } 
    };
    let customDistanceData = {}; let customDistanceStatus = 'pending'; let customDistanceError = null;

    // --- DOM Element References ---
    const sizeGrid = document.getElementById('size-grid'); const distAnchor = document.getElementById('dist-anchor'); const distPlanetsContainer = document.getElementById('dist-planets');
    const sizeLoading = document.getElementById('size-loading'); const sizeError = document.getElementById('size-error'); const distLoading = document.getElementById('dist-loading'); const distError = document.getElementById('dist-error');
    const customDistButton = document.getElementById('custom-dist-button'); const customDistButtonText = document.getElementById('custom-dist-button-text'); const customDistDropdown = document.getElementById('custom-dist-dropdown'); const customDistList = document.getElementById('custom-dist-list');
    const obsSection = document.getElementById('observability-section'); const obsChartContainer = document.getElementById('observability-chart'); const obsLoading = document.getElementById('obs-loading'); const obsError = document.getElementById('obs-error');   
    const obsTooltip = document.getElementById('observability-tooltip'); 

    // --- Utility Functions ---
    function toRadians(degrees) { return degrees * Math.PI / 180; }
    function getAngularSizeArcsec(diameterKm, distanceAu) { if (!diameterKm || !distanceAu || distanceAu <= 0) return 0; const distanceKm = distanceAu * AU_KM; const radiusKm = diameterKm / 2; const radians = 2 * Math.atan(radiusKm / distanceKm); return radians * 206264.806; }
    function calculateAngularSeparation(ra1Rad, dec1Rad, ra2Rad, dec2Rad) { if ([ra1Rad, dec1Rad, ra2Rad, dec2Rad].some(val => typeof val !== 'number' || isNaN(val))) { return NaN;} const cosAngle = Math.sin(dec1Rad) * Math.sin(dec2Rad) + Math.cos(dec1Rad) * Math.cos(dec2Rad) * Math.cos(ra1Rad - ra2Rad); const clampedCosAngle = Math.max(-1, Math.min(1, cosAngle)); return Math.acos(clampedCosAngle); }
    function lawOfCosines(distA_earth, distB_earth, angleA_E_B_rad) { if (isNaN(distA_earth) || isNaN(distB_earth) || isNaN(angleA_E_B_rad) || distA_earth < 0 || distB_earth < 0) { return NaN; } if (distA_earth === 0) return distB_earth; if (distB_earth === 0) return distA_earth; const distSq = Math.pow(distA_earth, 2) + Math.pow(distB_earth, 2) - 2 * distA_earth * distB_earth * Math.cos(angleA_E_B_rad); return Math.sqrt(Math.max(0, distSq)); }

    // --- ORIGINAL DASHBOARD DATA CALCULATION FUNCTIONS (RESTORED) ---
    function calculateTrueSizeData() { const modeData = displayData.trueSize; modeData.planets = {}; modeData.status = 'pending'; modeData.error = null; const targetMaxPx = getTargetMaxPxSize(); let maxDiameter = 0; const diameters = {}; PLANET_ORDER.forEach(p => { diameters[p] = PLANET_META[p]; if (diameters[p] > maxDiameter) maxDiameter = diameters[p]; }); if (maxDiameter <= 0) { console.error("[Calc True Size] Max diameter invalid."); modeData.status = 'error'; modeData.error = 'Invalid planet data'; return; } PLANET_ORDER.forEach(p => { const diameter = diameters[p]; const px = Math.max(4, (diameter / maxDiameter) * targetMaxPx); modeData.planets[p] = { px: px, label: `${diameter.toLocaleString()} km` }; }); modeData.status = 'ok'; }
    function calculateApparentSunData() { const modeData = displayData.apparentSun; modeData.planets = {}; modeData.status = 'pending'; modeData.error = null; const targetMaxPx = getTargetMaxPxSize(); let maxArcSec = 0; const arcSecs = {}; PLANET_ORDER.forEach(p => { const diameter = PLANET_META[p]; const distanceAu = PLANET_SMA[p]; const arcSec = getAngularSizeArcsec(diameter, distanceAu); arcSecs[p] = arcSec; if (arcSec > maxArcSec) maxArcSec = arcSec; }); if (maxArcSec <= 0) { console.error("[Calc Apparent Sun] Max arcsec invalid."); modeData.status = 'error'; modeData.error = 'Calculation error'; return; } PLANET_ORDER.forEach(p => { const arcSec = arcSecs[p]; const px = Math.max(4, (arcSec / maxArcSec) * targetMaxPx); modeData.planets[p] = { px: px, label: `${arcSec.toFixed(1)}″` }; }); modeData.status = 'ok'; }
    function calculateVisualHeightPct(planetId) { const currentMinPct = getCssVariableValue('--dist-planet-min-height-pct') || MIN_PLANET_VISUAL_HEIGHT_PCT; const currentBasePct = getCssVariableValue('--dist-planet-base-height-pct') || BASE_PLANET_VISUAL_HEIGHT_PCT; const currentMaxPct = getCssVariableValue('--dist-planet-max-height-pct') || MAX_PLANET_VISUAL_HEIGHT_PCT; const jupiterDiameter = PLANET_META.jupiter; if (!jupiterDiameter) return currentMinPct; let diameterToUse = PLANET_META[planetId]; if (!diameterToUse) return currentMinPct; const rawVisualHeightPct = (diameterToUse / jupiterDiameter) * currentBasePct; return Math.max(currentMinPct, Math.min(currentMaxPct, rawVisualHeightPct));}
    function calculateDistSunData() { const modeData = displayData.distSun; modeData.planets = {}; modeData.status = 'pending'; modeData.error = null; const maxDist = PLANET_SMA.neptune; PLANET_ORDER.forEach(p => { const distanceAu = PLANET_SMA[p]; const pos = (distanceAu / maxDist) * 100; const visualHeightPct = calculateVisualHeightPct(p); modeData.planets[p] = { pos: pos, label: `${distanceAu.toFixed(3)} AU`, visH: visualHeightPct }; }); modeData.status = 'ok'; }
    function calculateApparentEarthData(currentDayLiveApiDataMap) { const modeData = displayData.apparentEarth; modeData.planets = {}; modeData.status = 'pending'; modeData.error = null; if (!currentDayLiveApiDataMap || Object.keys(currentDayLiveApiDataMap).length === 0) { console.error("[Calc Apparent Earth] Missing or empty currentDayLiveApiDataMap."); modeData.status = 'error'; modeData.error = 'API data not available'; return; } const targetMaxPx = getTargetMaxPxSize(); let maxArcSec = 0; const arcSecs = {}; let calculationOk = true; let firstErrorLogged = false; PLANET_ORDER.forEach(p => { if (p === 'earth') return; const diameter = PLANET_META[p]; const planetData = currentDayLiveApiDataMap[p]; const distanceAu = planetData?.distEarth; if (isNaN(distanceAu) || distanceAu <= 0) { if (!firstErrorLogged && !hasLoggedApiStructure) { firstErrorLogged = true; hasLoggedApiStructure = true; } arcSecs[p] = -1; calculationOk = false; } else { const arcSec = getAngularSizeArcsec(diameter, distanceAu); arcSecs[p] = arcSec; if (arcSec > maxArcSec) maxArcSec = arcSec; } }); if (!calculationOk && maxArcSec <= 0) { console.error("[Calc Apparent Earth] No valid distances found."); modeData.status = 'error'; modeData.error = 'Could not read valid planet distances from API data.'; return; } if (maxArcSec <= 0) { maxArcSec = 1; } PLANET_ORDER.forEach(p => { if (p === 'earth') return; const arcSec = arcSecs[p]; if (arcSec < 0) { modeData.planets[p] = { px: 4, label: `??” (No data)` }; } else { const px = Math.max(4, (arcSec / maxArcSec) * targetMaxPx); modeData.planets[p] = { px: px, label: `${arcSec.toFixed(1)}″` }; } }); modeData.status = calculationOk ? 'ok' : 'partial'; modeData.error = calculationOk ? null : 'API data missing required distance field for some planets.'; }
    function calculateDistEarthData(currentDayLiveApiDataMap) { const modeData = displayData.distEarth; modeData.planets = {}; modeData.status = 'pending'; modeData.error = null; if (!currentDayLiveApiDataMap || Object.keys(currentDayLiveApiDataMap).length === 0) { console.error("[Calc Dist Earth] Missing or empty currentDayLiveApiDataMap."); modeData.status = 'error'; modeData.error = 'API data not available'; return; } const distances = []; let calculationOk = true; let firstErrorLogged = false; PLANET_ORDER.forEach(p => { if (p === 'earth') return; const planetData = currentDayLiveApiDataMap[p]; const distanceAu = planetData?.distEarth; if (!isNaN(distanceAu) && distanceAu > 0) { distances.push({ id: p, dist: distanceAu }); const visualHeightPct = calculateVisualHeightPct(p); modeData.planets[p] = { visH: visualHeightPct, label: `${distanceAu.toFixed(3)} AU` }; } else { if (!firstErrorLogged && !hasLoggedApiStructure) { firstErrorLogged = true; hasLoggedApiStructure = true; } calculationOk = false; } }); if (distances.length === 0 && !calculationOk) { console.error("[Calc Dist Earth] No valid distances found, and calculation was not OK."); modeData.status = 'error'; modeData.error = 'Could not read valid planet distances from API data.'; return; } if (distances.length === 0 && calculationOk) { modeData.status = 'ok'; modeData.planets = {}; return; } const maxDist = Math.max(...distances.map(item => item.dist)); distances.forEach(item => { const p = item.id; const distanceAu = item.dist; const pos = (maxDist > 0) ? (distanceAu / maxDist) * 100 : 0; if (modeData.planets[p]) { modeData.planets[p].pos = pos; } }); modeData.status = calculationOk ? 'ok' : 'partial'; modeData.error = calculationOk ? null : 'API data missing required distance field for some planets.'; }
    function calculateAllCustomDistData(currentDayLiveApiDataMap) { customDistanceData = {}; customDistanceStatus = 'pending'; customDistanceError = null; if (!currentDayLiveApiDataMap || Object.keys(currentDayLiveApiDataMap).length === 0) { console.error("[Calc Custom] Missing or empty currentDayLiveApiDataMap."); customDistanceStatus = 'error'; customDistanceError = 'API data not available'; return; } let overallOk = true; try { OBSERVABLE_PLANETS.forEach(anchorId => { customDistanceData[anchorId] = { planets: {}, status: 'pending', error: null }; const anchorData = currentDayLiveApiDataMap[anchorId]; if (!anchorData || isNaN(anchorData.raRad) || isNaN(anchorData.decRad) || isNaN(anchorData.distEarth)) { customDistanceData[anchorId].status = 'error'; customDistanceData[anchorId].error = `Missing base data for ${anchorId}`; overallOk = false; return; } const targetPlanets = [...PLANET_ORDER]; let anchorSpecificOk = true; targetPlanets.forEach(targetId => { if (targetId === anchorId) return; const targetData = currentDayLiveApiDataMap[targetId]; if (!targetData || isNaN(targetData.raRad) || isNaN(targetData.decRad) || isNaN(targetData.distEarth)) { customDistanceData[anchorId].planets[targetId] = { dist: 'N/A', label: 'N/A', visH: calculateVisualHeightPct(targetId) }; anchorSpecificOk = false; overallOk = false; return; } const angularSepRad = calculateAngularSeparation(anchorData.raRad, anchorData.decRad, targetData.raRad, targetData.decRad); const distanceAU = lawOfCosines(anchorData.distEarth, targetData.distEarth, angularSepRad); if (isNaN(distanceAU)) { customDistanceData[anchorId].planets[targetId] = { dist: 'Error', label: 'Error', visH: calculateVisualHeightPct(targetId) }; anchorSpecificOk = false; overallOk = false; } else { customDistanceData[anchorId].planets[targetId] = { dist: distanceAU, label: `${distanceAU.toFixed(3)} AU`, visH: calculateVisualHeightPct(targetId) }; } }); customDistanceData[anchorId].status = anchorSpecificOk ? 'ok' : 'partial'; }); } catch (error) { console.error("[Calc Custom] Error during calculation loop:", error); customDistanceStatus = 'error'; customDistanceError = `Calculation error: ${error.message}`; return; } customDistanceStatus = overallOk ? 'ok' : 'partial'; customDistanceError = overallOk ? null : 'Could not calculate some inter-planet distances.'; }
    
    // --- NEW/UPDATED Observability Calculation Functions ---
    function getObservabilityColor(score) { 
        const s = Math.round(Math.max(0, Math.min(100, score))); 
        return OBSERVABILITY_COLORS[s] || '#808080'; 
    }
    function calculateCombinedScore(elongation, magnitude) {
        if (typeof elongation !== 'number' || isNaN(elongation) || typeof magnitude !== 'number' || isNaN(magnitude)) { return 0; }
        const elongFactor = 1 / (1 + Math.exp(-0.3 * (elongation - 25)));
        const magFactor = (-(50 / 9) * magnitude) + (670 / 9);
        let score = elongFactor * magFactor;
        score = Math.round(Math.max(0, Math.min(100, score))); 
        return score;
    }

    function calculateObservabilityData(forecastApiData) { 
        const modeData = displayData.observability;
        modeData.planets = {}; 
        if (!forecastApiData || Object.keys(forecastApiData).length === 0 || !forecastApiData.sun) {
            modeData.status = 'pending'; 
            modeData.error = 'Forecast data not yet available or incomplete from API.';
            OBSERVABLE_PLANETS.forEach(planetId => { 
                modeData.planets[planetId] = { actualMagnitudes: [], calculatedElongations: [], dailyScores: [] };
            });
            return;
        }
        modeData.status = 'processing'; 
        modeData.error = null;
        const sunDailyData = forecastApiData.sun;

        OBSERVABLE_PLANETS.forEach((planetId) => {
            const planetDailyForecast = forecastApiData[planetId];
            const dailyMagnitudes = []; const dailyElongations = []; const dailyScores = [];
            if (!planetDailyForecast || planetDailyForecast.length === 0) {
                modeData.planets[planetId] = { actualMagnitudes: [], calculatedElongations: [], dailyScores: [] };
                return; 
            }
            for (let i = 0; i < planetDailyForecast.length; i += OBSERVABILITY_DAY_STEP) {
                const dayDataPlanet = planetDailyForecast[i];
                const dayDataSun = (sunDailyData && i < sunDailyData.length) ? sunDailyData[i] : null; 
                if (!dayDataPlanet || !dayDataSun || !dayDataPlanet.position?.equatorial || !dayDataSun.position?.equatorial) {
                    dailyMagnitudes.push(null); dailyElongations.push(null); dailyScores.push(0); 
                    continue;
                }
                const currentMag = dayDataPlanet.magnitude;
                dailyMagnitudes.push(typeof currentMag === 'number' ? parseFloat(currentMag.toFixed(1)) : null);
                const planetRaRad = toRadians(parseFloat(dayDataPlanet.position.equatorial.rightAscension?.hours) * 15);
                const planetDecRad = toRadians(parseFloat(dayDataPlanet.position.equatorial.declination?.degrees));
                const sunRaRad = toRadians(parseFloat(dayDataSun.position.equatorial.rightAscension?.hours) * 15);
                const sunDecRad = toRadians(parseFloat(dayDataSun.position.equatorial.declination?.degrees));
                let currentElong = NaN;
                if (![planetRaRad, planetDecRad, sunRaRad, sunDecRad].some(isNaN)) {
                    currentElong = calculateAngularSeparation(planetRaRad, planetDecRad, sunRaRad, sunDecRad) * (180 / Math.PI); 
                }
                dailyElongations.push(!isNaN(currentElong) ? parseFloat(currentElong.toFixed(1)) : null);
                const combinedScore = calculateCombinedScore(currentElong, currentMag);
                dailyScores.push(combinedScore);
            }
            modeData.planets[planetId] = { actualMagnitudes: dailyMagnitudes, calculatedElongations: dailyElongations, dailyScores: dailyScores };
        });
        modeData.status = 'ok';
    }

    // --- API Fetching and Data Processing ---
    async function fetchAndUpdateLiveData() {
        hasLoggedApiStructure = false; 
        Object.keys(displayData).forEach(key => { displayData[key].status = 'pending'; displayData[key].error = null;});
        customDistanceStatus = 'pending'; customDistanceError = null;
        showLoading('size', true); showLoading('dist', true); showLoading('obs', true);
        apiFetchError = null;

        try {
            const response = await fetch('/.netlify/functions/planetDashboard');
            if (!response.ok) { const errorText = await response.text(); throw new Error(`API Error ${response.status}: ${errorText.substring(0,100)}`); }
            const rawCombinedData = await response.json();

            if (rawCombinedData && rawCombinedData.data && rawCombinedData.data.table && rawCombinedData.data.table.rows) {
                liveApiData = {}; 
                rawCombinedData.data.table.rows.forEach(row => {
                    const id = row.entry?.id?.toLowerCase(); const cell = row.cells?.[0]; 
                    if (!id || !cell) { return; }
                    const distNum = parseFloat(cell.distance?.fromEarth?.au);
                    const raHoursNum = parseFloat(cell.position?.equatorial?.rightAscension?.hours);
                    const decDegNum = parseFloat(cell.position?.equatorial?.declination?.degrees);
                    const magnitude = cell.apparentMagnitude; 
                    const currentElong = cell.currentElongation; 
                    liveApiData[id] = { id: id, name: row.entry?.name, distEarth: isNaN(distNum)?NaN:distNum, raRad: isNaN(raHoursNum)?NaN:toRadians(raHoursNum*15), decRad: isNaN(decDegNum)?NaN:toRadians(decDegNum), magnitude: (typeof magnitude==='number'&&!isNaN(magnitude))?magnitude:null, currentElongation: (typeof currentElong==='number'&&!isNaN(currentElong))?currentElong:null };
                });
                if (!liveApiData.earth) { liveApiData.earth = { id: 'earth', name: 'Earth', distEarth: 0, raRad: 0, decRad: 0, magnitude: null, currentElongation: null }; }
            } else {
                liveApiData = null; 
            }

            observabilityForecastData = rawCombinedData.observabilityForecast; 
            if (!observabilityForecastData || Object.keys(observabilityForecastData).length === 0 || !observabilityForecastData.sun) {
                observabilityForecastData = null; 
            }
            
            apiFetchError = rawCombinedData.partialError || null; 
            if(apiFetchError) console.warn(`[API WARN] Partial errors from Netlify function: ${apiFetchError}`);

            calculateTrueSizeData(); calculateApparentSunData(); calculateDistSunData();
            if (liveApiData && Object.keys(liveApiData).length > 0) { 
                calculateApparentEarthData(liveApiData); calculateDistEarthData(liveApiData); calculateAllCustomDistData(liveApiData); 
            } else {
                displayData.apparentEarth.status = 'error'; displayData.apparentEarth.error = "Current day API data missing.";
                displayData.distEarth.status = 'error';    displayData.distEarth.error = "Current day API data missing.";
                customDistanceStatus = 'error'; customDistanceError = "Current day API data missing for custom calcs.";
            }
            calculateObservabilityData(observabilityForecastData); 

        } catch (error) {
            console.error("[API CRITICAL ERROR] in fetchAndUpdateLiveData (client-side catch):", error);
            apiFetchError = error.message; liveApiData = null; observabilityForecastData = null; 
            Object.keys(displayData).forEach(key => { displayData[key].status = 'error'; displayData[key].error = apiFetchError; });
            customDistanceStatus = 'error'; customDistanceError = apiFetchError;
        } finally {
            showLoading('size', false); showLoading('dist', false); showLoading('obs', false);
            drawSizeGrid(); drawDistanceChart(); drawObservabilityChart(); 
            clearTimeout(apiRefreshTimer); apiRefreshTimer = setTimeout(fetchAndUpdateLiveData, REFRESH_INTERVAL_MS);
        }
    }

    // --- UI Update Functions ---
    function showLoading(panelType, isLoading) { let element; if (panelType === 'size') element = sizeLoading; else if (panelType === 'dist') element = distLoading; else if (panelType === 'obs') element = obsLoading; if (element) element.style.display = isLoading ? 'flex' : 'none'; }
    function showError(panelType, message) { let element; let displayMessage = message; if (panelType === 'size') { element = sizeError; if (displayData[currentSizeMode]?.status === 'error') displayMessage = displayData[currentSizeMode].error || message; } else if (panelType === 'dist') { element = distError; if (currentDistMode === 'custom' && customDistanceStatus === 'error') displayMessage = customDistanceError || message; else if (displayData[currentDistMode]?.status === 'error') displayMessage = displayData[currentDistMode].error || message; } else if (panelType === 'obs') { element = obsError; if (displayData.observability?.status === 'error') displayMessage = displayData.observability.error || message; } if (element) { element.textContent = displayMessage || ''; element.style.display = displayMessage ? 'flex' : 'none'; } }
    function drawSizeGrid() { const modeData = displayData[currentSizeMode]; if (!modeData || (modeData.status !== 'ok' && modeData.status !== 'partial')) { showLoading('size', modeData?.status === 'pending'); showError('size', modeData?.status === 'error' ? (modeData.error || 'Failed to load size data.') : null); if(sizeGrid) sizeGrid.innerHTML = ''; return; } showLoading('size', false); showError('size', modeData.status === 'partial' ? (modeData.error || 'Note: Some planet size data may be missing.') : null); const planetDataMap = modeData.planets; if(!sizeGrid) {return;} sizeGrid.innerHTML = ''; const planetsToShow = (currentSizeMode === 'apparentEarth') ? OBSERVABLE_PLANETS : PLANET_ORDER; planetsToShow.forEach(p => { const planetData = planetDataMap[p]; const slot = document.createElement('div'); slot.className = 'planet-slot'; slot.id = `slot-${p}`; if (p === 'earth' && currentSizeMode === 'apparentEarth') return; if (planetData && typeof planetData.px === 'number') { const imgContainer = document.createElement('div'); imgContainer.className = 'planet-image-container'; const img = document.createElement('img'); img.src = `planets/${p}.png`; img.alt = p; img.onerror = function() { this.style.display='none'; slot.querySelector('.size-label').textContent = 'Image N/A';}; img.style.height = `${planetData.px}px`; img.style.width = 'auto'; imgContainer.appendChild(img); const label = document.createElement('div'); label.className = 'size-label'; label.textContent = planetData.label || 'N/A'; slot.appendChild(imgContainer); slot.appendChild(label); } else { slot.innerHTML = `<div class="planet-image-container" style="color:var(--color-text-secondary); display:flex; align-items:center; justify-content:center; font-size: var(--cell); ">?</div><div class="size-label">No data for ${p}</div>`; } sizeGrid.appendChild(slot); }); }
    function drawDistanceChart() { if (!distAnchor || !distPlanetsContainer) { return; } distPlanetsContainer.innerHTML = ''; distAnchor.style.display = 'none'; showLoading('dist', false); showError('dist', null); let planetDataMap; let anchorId = 'earth'; let isSunMode = false; let isCustomMode = currentDistMode === 'custom'; if (isCustomMode) { if (!selectedCustomPlanet) { showError('dist', 'Please select a custom anchor planet.'); return; } if (customDistanceStatus === 'pending') { showLoading('dist', true); return; } if (customDistanceStatus === 'error' || !customDistanceData[selectedCustomPlanet] || customDistanceData[selectedCustomPlanet].status === 'error') { showError('dist', customDistanceData[selectedCustomPlanet]?.error || customDistanceError || 'Could not calculate custom distances.'); return; } if (customDistanceData[selectedCustomPlanet].status === 'partial') { showError('dist', customDistanceData[selectedCustomPlanet].error || 'Could not calculate some distances for the selected anchor.'); } planetDataMap = customDistanceData[selectedCustomPlanet].planets; if (!planetDataMap) { showError('dist', `No distance data available for ${selectedCustomPlanet}.`); return; } anchorId = selectedCustomPlanet; } else { const modeData = displayData[currentDistMode]; if (!modeData || (modeData.status !== 'ok' && modeData.status !== 'partial')) { showLoading('dist', modeData?.status === 'pending'); showError('dist', modeData?.status === 'error' ? (modeData.error || 'Failed to load distance data.') : null); return; } showError('dist', modeData.status === 'partial' ? (modeData.error || 'Note: Some planet distance data may be missing.') : null); planetDataMap = modeData.planets; isSunMode = currentDistMode === 'distSun'; anchorId = isSunMode ? 'sun' : 'earth'; } distAnchor.style.display = 'block'; distAnchor.src = `planets/${anchorId}.png`; distAnchor.onerror = function() { this.style.display='none'; }; let anchorVisH; if (anchorId === 'sun') { const sunDiameter = PLANET_META.sun; const jupiterDiameter = PLANET_META.jupiter; anchorVisH = (sunDiameter && jupiterDiameter) ? (sunDiameter / jupiterDiameter) * (getCssVariableValue('--dist-planet-base-height-pct') || BASE_PLANET_VISUAL_HEIGHT_PCT) : (getCssVariableValue('--dist-planet-base-height-pct') || BASE_PLANET_VISUAL_HEIGHT_PCT) * 5; distAnchor.style.height = `${anchorVisH}%`; distAnchor.style.maxHeight = 'none'; distAnchor.style.transform = 'translate(-100%, -50%)'; } else { anchorVisH = calculateVisualHeightPct(anchorId); distAnchor.style.height = `${anchorVisH}%`; distAnchor.style.maxHeight = `${getCssVariableValue('--dist-planet-max-height-pct') || MAX_PLANET_VISUAL_HEIGHT_PCT}%`; distAnchor.style.transform = 'translate(-50%, -50%)'; } let targets = []; let maxDist = 0; if (isCustomMode) { const customPlanets = customDistanceData[selectedCustomPlanet].planets; PLANET_ORDER.forEach(p => { if (p === selectedCustomPlanet) return; const planetInfo = customPlanets[p]; if (planetInfo && typeof planetInfo.dist === 'number' && !isNaN(planetInfo.dist) && planetInfo.dist > 0) { targets.push({ id: p, dist: planetInfo.dist, label: planetInfo.label, visH: planetInfo.visH }); if (planetInfo.dist > maxDist) maxDist = planetInfo.dist; } }); } else { const standardPlanets = isSunMode ? PLANET_ORDER : PLANET_ORDER.filter(p => p !== 'earth'); standardPlanets.forEach(p => { const data = planetDataMap[p]; if (data && typeof data.pos === 'number') { let distValue; if (currentDistMode === 'distEarth' && liveApiData?.[p]) distValue = liveApiData[p].distEarth; else if (currentDistMode === 'distSun') distValue = PLANET_SMA[p]; if (typeof distValue === 'number' && !isNaN(distValue) && distValue >= 0) { targets.push({ id: p, dist: distValue, label: data.label, visH: data.visH }); if (distValue > maxDist) maxDist = distValue; } } }); } if (maxDist <= 0 && targets.length > 0) { maxDist = 1; } else if (targets.length === 0) { return; } targets.forEach(target => { const p = target.id; const distanceAu = target.dist; const positionPct = (maxDist > 0) ? (distanceAu / maxDist) * 100 : 0; const labelText = target.label; const visualHeightPct = target.visH || calculateVisualHeightPct(p); const img = document.createElement('img'); img.src = `planets/${p}.png`; img.alt = p; img.className = 'dist-planet-img'; img.onerror = function() { this.style.display='none';}; img.style.left = `${positionPct}%`; img.style.height = `${visualHeightPct}%`; distPlanetsContainer.appendChild(img); const label = document.createElement('div'); label.className = 'dist-label'; const labelNudgeX = (isSunMode && PLANET_ORDER.indexOf(p) < 4 && positionPct < 20) ? 15 : 0; const labelNudgeY = (isSunMode && PLANET_ORDER.indexOf(p) < 2 && positionPct < 10) ? -10 : 0; label.style.left = `calc(${positionPct}% + ${labelNudgeX}px)`; label.style.top = `calc(50% - 40px + ${labelNudgeY}px)`; label.textContent = labelText; distPlanetsContainer.appendChild(label); }); }
    function drawObservabilityChart() { if (!obsChartContainer) { return; } const modeData = displayData.observability; if (!modeData || (modeData.status !== 'ok' && modeData.status !== 'partial')) { showLoading('obs', modeData?.status === 'pending'); showError('obs', modeData?.status === 'error' ? (modeData.error || 'Failed to load observability data.') : null); obsChartContainer.innerHTML = ''; return; } showLoading('obs', false); showError('obs', modeData.status === 'partial' ? (modeData.error || 'Note: Some observability data may be incomplete.') : null); obsChartContainer.innerHTML = ''; OBSERVABLE_PLANETS.forEach(planetId => { const planetObsData = modeData.planets[planetId]; if (!planetObsData || !planetObsData.dailyScores || planetObsData.dailyScores.length === 0) { const row = document.createElement('div'); row.className = 'observability-planet-row'; const label = document.createElement('div'); label.className = 'observability-planet-label'; label.textContent = planetId; row.appendChild(label); const barContainer = document.createElement('div'); barContainer.className = 'observability-bar-container'; const bar = document.createElement('div'); bar.className = 'observability-bar'; bar.style.background = 'var(--color-medium-grey)'; barContainer.appendChild(bar); row.appendChild(barContainer); obsChartContainer.appendChild(row); return; } const row = document.createElement('div'); row.className = 'observability-planet-row'; const label = document.createElement('div'); label.className = 'observability-planet-label'; label.textContent = planetId; row.appendChild(label); const barContainer = document.createElement('div'); barContainer.className = 'observability-bar-container'; const bar = document.createElement('div'); bar.className = 'observability-bar'; bar.dataset.planetId = planetId; let gradientCss = 'linear-gradient(to right'; const numSegments = planetObsData.dailyScores.length; planetObsData.dailyScores.forEach((score, segmentIndex) => { const color = getObservabilityColor(score); const startPercent = (segmentIndex / numSegments) * 100; const endPercent = ((segmentIndex + 1) / numSegments) * 100; gradientCss += `, ${color} ${startPercent.toFixed(2)}%, ${color} ${endPercent.toFixed(2)}%`; }); gradientCss += ')'; bar.style.background = gradientCss; bar.addEventListener('mouseenter', handleObsBarHover); bar.addEventListener('mousemove', handleObsBarHover); bar.addEventListener('mouseleave', () => { if(obsTooltip) obsTooltip.style.display = 'none'; }); barContainer.appendChild(bar); row.appendChild(barContainer); obsChartContainer.appendChild(row); }); }
    
    function handleObsBarHover(event) {
        // console.log('[HOVER] Event Type:', event.type); // Basic check if events are firing
        if (!obsTooltip || !displayData.observability?.planets) {
            // console.log('[HOVER] Tooltip or planet data missing in displayData.');
            if(obsTooltip) obsTooltip.style.display = 'none'; // Ensure it's hidden if data is bad
            return;
        }
        const bar = event.currentTarget;
        const planetId = bar.dataset.planetId;
        const planetData = displayData.observability.planets[planetId];

        if (!planetData || !planetData.dailyScores || planetData.dailyScores.length === 0) {
            obsTooltip.style.display = 'none';
            // console.log(`[HOVER] No daily scores for ${planetId}, hiding tooltip.`);
            return;
        }

        const rect = bar.getBoundingClientRect();
        const xInBar = event.clientX - rect.left;
        const barWidth = rect.width;
        const numSegments = planetData.dailyScores.length;
        
        // Ensure barWidth is positive to avoid division by zero or negative segmentIndex
        if (barWidth <= 0) {
            obsTooltip.style.display = 'none';
            // console.log('[HOVER] Bar width is zero or negative, cannot calculate segment.');
            return;
        }

        const segmentIndex = Math.min(numSegments - 1, Math.max(0, Math.floor((xInBar / barWidth) * numSegments)));
        const dayNumberInYear = segmentIndex * OBSERVABILITY_DAY_STEP + 1;

        // console.log(`[HOVER] Planet: ${planetId}, Bar Width: ${barWidth}, xInBar: ${xInBar}, Num Segments: ${numSegments}, Seg Index: ${segmentIndex}`);

        if (segmentIndex >= 0 && segmentIndex < numSegments) {
            const mag = planetData.actualMagnitudes[segmentIndex];
            const elong = planetData.calculatedElongations[segmentIndex];
            const score = planetData.dailyScores[segmentIndex];
            
            obsTooltip.innerHTML = `<div>Day ${dayNumberInYear} (Score: ${score}/100)</div><div>Mag: ${mag !== null && !isNaN(mag) ? mag.toFixed(1) : 'N/A'}</div><div>Elong: ${elong !== null && !isNaN(elong) ? elong.toFixed(1) : 'N/A'}°</div>`;
            obsTooltip.style.display = 'block';
            
            const tooltipHeight = obsTooltip.offsetHeight;
            const tooltipWidth = obsTooltip.offsetWidth; // Get width after content is set

            let top = event.clientY - tooltipHeight - 15; // 15px gap above cursor
            let left = event.clientX - (tooltipWidth / 2); // Center horizontally on cursor

            // Boundary checks
            if (top < 5) { // If too close to top of viewport, flip below cursor
                top = event.clientY + 20;
            }
            if (left < 5) { // If too close to left edge
                left = 5;
            }
            if (left + tooltipWidth > window.innerWidth - 5) { // If too close to right edge
                left = window.innerWidth - tooltipWidth - 5;
            }

            obsTooltip.style.left = `${left}px`;
            obsTooltip.style.top = `${top}px`;
            obsTooltip.style.transform = ''; // Ensure no old transform is interfering
            // console.log(`[HOVER] Tooltip for ${planetId}, Day ${dayNumberInYear}: Mag=${mag}, Elong=${elong}, Score=${score}. Pos: L${left}px T${top}px`);

        } else {
            obsTooltip.style.display = 'none';
            // console.log('[HOVER] Segment index out of bounds, hiding tooltip.');
        }
    }
    
    function toggleCustomDropdown(forceClose = false) { if(!customDistDropdown||!customDistButton)return; const sS=!customDistDropdown.classList.contains('show')&&!forceClose; customDistDropdown.classList.toggle('show',sS); customDistButton.classList.toggle('open',sS); if(sS)updateDropdownHighlight(); }
    function updateDropdownHighlight() { if(!customDistList)return; customDistList.querySelectorAll('li').forEach(li=>li.classList.toggle('selected',li.dataset.planet===selectedCustomPlanet)); }
    function selectCustomPlanet(planetId) { selectedCustomPlanet=planetId; currentDistMode='custom'; if(customDistButtonText)customDistButtonText.textContent=planetId.charAt(0).toUpperCase()+planetId.slice(1); document.querySelectorAll('#dist-mode-switch button').forEach(b=>b.classList.remove('active')); if(customDistButton)customDistButton.classList.add('active'); toggleCustomDropdown(true); drawDistanceChart(); }
    function populateCustomDropdown() { if(!customDistList)return; customDistList.innerHTML=''; OBSERVABLE_PLANETS.forEach(p=>{const li=document.createElement('li');li.textContent=p.charAt(0).toUpperCase()+p.slice(1);li.dataset.planet=p;customDistList.appendChild(li);}); }
    document.querySelectorAll('#dist-mode-switch button[data-mode="distSun"],#dist-mode-switch button[data-mode="distEarth"]').forEach(btn=>{btn.addEventListener('click',e=>{const tB=e.currentTarget;if(!tB.disabled&&!tB.classList.contains('active')){ const nM=tB.dataset.mode;currentDistMode=nM;selectedCustomPlanet=null;if(customDistButtonText)customDistButtonText.textContent='custom';document.querySelectorAll('#dist-mode-switch button').forEach(b=>b.classList.remove('active'));tB.classList.add('active');if(customDistButton)customDistButton.classList.remove('active');toggleCustomDropdown(true);drawDistanceChart();}});});
    if(customDistButton)customDistButton.addEventListener('click',e=>{e.stopPropagation();toggleCustomDropdown();});
    if(customDistList)customDistList.addEventListener('click',e=>{if(e.target.tagName==='LI'&&e.target.dataset.planet){e.stopPropagation();selectCustomPlanet(e.target.dataset.planet);}});
    document.addEventListener('click',e=>{if(customDistDropdown&&customDistDropdown.classList.contains('show')){if(!customDistButton?.contains(e.target)&&!customDistDropdown.contains(e.target)){toggleCustomDropdown(true);}}});
    document.getElementById('size-mode-switch').addEventListener('click',e=>{if(e.target.tagName==='BUTTON'&&!e.target.disabled&&!e.target.classList.contains('active')){ const nM=e.target.dataset.mode;currentSizeMode=nM;e.target.parentNode.querySelectorAll('button').forEach(b=>b.classList.remove('active'));e.target.classList.add('active');drawSizeGrid();}});
    let resizeTimeout;
    window.addEventListener('resize',()=>{ clearTimeout(resizeTimeout);resizeTimeout=setTimeout(()=>{ BASE_PLANET_VISUAL_HEIGHT_PCT=getCssVariableValue('--dist-planet-base-height-pct')||35;MIN_PLANET_VISUAL_HEIGHT_PCT=getCssVariableValue('--dist-planet-min-height-pct')||5;MAX_PLANET_VISUAL_HEIGHT_PCT=getCssVariableValue('--dist-planet-max-height-pct')||80;calculateTrueSizeData();calculateApparentSunData();calculateDistSunData();calculateObservabilityData(observabilityForecastData);if(liveApiData){calculateApparentEarthData(liveApiData);calculateDistEarthData(liveApiData);calculateAllCustomDistData(liveApiData);}drawSizeGrid();drawDistanceChart();drawObservabilityChart(); },250);});
    function initializeDashboard() {
        const essentialDOM=[sizeGrid,distAnchor,distPlanetsContainer,sizeLoading,sizeError,distLoading,distError,customDistButton,customDistButtonText,customDistDropdown,customDistList,obsSection,obsChartContainer,obsLoading,obsError, obsTooltip ];
        if(essentialDOM.some(el=>!el)){console.error("[CRITICAL ERROR] Essential DOM elements missing on init.");document.body.innerHTML='<p style="color:var(--color-text-error);padding:50px;text-align:center;font-size:1.2rem;">Error: Page components missing.</p>';return;}
        BASE_PLANET_VISUAL_HEIGHT_PCT=getCssVariableValue('--dist-planet-base-height-pct')||35; MIN_PLANET_VISUAL_HEIGHT_PCT=getCssVariableValue('--dist-planet-min-height-pct')||5; MAX_PLANET_VISUAL_HEIGHT_PCT=getCssVariableValue('--dist-planet-max-height-pct')||80;
        populateCustomDropdown();
        calculateTrueSizeData();calculateApparentSunData();calculateDistSunData();
        calculateObservabilityData(null); 
        sizeGrid.innerHTML=''; PLANET_ORDER.forEach(p=>{const s=document.createElement('div');s.className='planet-slot';s.id=`slot-${p}`;s.innerHTML=`<div class="planet-image-container"></div><div class="size-label"id="lbl-${p}"></div>`;sizeGrid.appendChild(s);});
        if(displayData[currentSizeMode]?.status==='ok')drawSizeGrid();else showLoading('size',true);
        if(displayData[currentDistMode]?.status==='ok'&&currentDistMode!=='custom')drawDistanceChart();else if(currentDistMode!=='custom')showLoading('dist',true);
        drawObservabilityChart(); 
        if(displayData.observability?.status !== 'ok') showLoading('obs',true);
        fetchAndUpdateLiveData();
    }
    function toggleModal() { const modal = document.getElementById('modal'); const backdrop = document.getElementById('modal-backdrop'); if (!modal || !backdrop) {return;} const isOpen = modal.classList.contains('open'); modal.classList.toggle('open', !isOpen); backdrop.classList.toggle('open', !isOpen); document.body.classList.toggle('modal-open', !isOpen); }
    document.addEventListener('DOMContentLoaded', initializeDashboard);
 </script>
 <script src="/scripts.js"></script>
 </body>
</html>