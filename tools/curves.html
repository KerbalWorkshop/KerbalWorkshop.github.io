<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>New Tool – Hansen Space</title>
  
  <!-- Font-face declarations -->
  <style>
    @font-face {
      font-family: 'Moon';
      src: url('/fonts/Moon-Regular.woff2') format('woff2'),
           url('/fonts/Moon-Regular.woff') format('woff');
      font-weight: normal;
      font-style: normal;
    }
    @font-face {
      font-family: 'Moon Bold';
      src: url('/fonts/Moon-Bold.woff2') format('woff2'),
           url('/fonts/Moon-Bold.woff') format('woff');
      font-weight: bold;
      font-style: normal;
    }
    
    body {
      font-family: 'Moon', sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      background: #f8f8f8;
    }
    
    header, footer {
      flex: 0 0 auto;
    }
    
    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
    }
    
    /* Intro section with instructions */
    #intro {
      width: 100%;
      background: #fff;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-bottom: 20px;
      text-align: left;
    }
    #intro h2 {
      font-size: 24px;
      font-weight: bold;
      text-align: center;
      margin-bottom: 10px;
    }
    #intro ol {
      font-size: 14px;
      font-weight: normal;
      margin-left: 20px;
      line-height: 1.4;
    }
    #intro li {
      margin-bottom: 5px;
    }
    
    /* Back button styling */
    #backButton {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1100;
      background: #fff;
      border: 1px solid #000;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      text-align: center;
      line-height: 36px;
      font-size: 18px;
      color: #000;
      cursor: pointer;
      padding: 0;
    }
    
    /* Graph container styling */
    #graphContainer {
      width: 600px;
      height: 400px;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      position: relative;
      margin-bottom: 20px;
    }
    
    /* Popup with position: fixed so it can go anywhere on screen */
    #popup {
      position: fixed; /* key: not relative to chart container */
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin: 0;
      padding: 2px 6px; /* minimal padding */
      z-index: 3000;
      display: none;
      font-size: 16px;
      font-family: 'Moon', sans-serif;
      box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
      white-space: normal;
    }
    #popup .close-btn {
      position: absolute;
      top: 2px;
      right: 5px;
      cursor: pointer;
      font-size: 20px;
      font-weight: bold;
      color: #333;
    }
    .dynamic {
      color: darkblue;
      font-weight: bold;
    }
  </style>
  
  <link rel="stylesheet" href="../styles.css">
</head>
<body>
  <!-- Header -->
  <header>
    <a class="brand" href="/index.html">
      <img src="/images/logo.png" alt="Hansen Space Logo">
    </a>
    <nav>
      <ul>
        <li><a href="/index.html">Home</a></li>
        <li><a href="/myjourney.html">My Journey</a></li>
        <li><a href="/photography.html">Photography</a></li>
        <li><a href="/articles.html">Articles</a></li>
        <li><a href="/tools.html">Tools</a></li>
      </ul>
    </nav>
  </header>
  
  <!-- Main content -->
  <main>
    <button id="backButton" onclick="location.href='../tools.html'">&#8592;</button>
    
    <!-- Intro section with general instructions -->
    <section id="intro">
      <h2>Light Curve Viewer</h2>
      <ol>
        <li>Graphs show variable stars' live position on phase curve.</li>
        <li>Click anywhere on the graph to when the star will be at that brightness.</li>
      </ol>
    </section>
    
    <!-- Graph container -->
    <section id="graphContainer">
      <canvas id="lightCurveChart" width="600" height="400"></canvas>
    </section>
    
    <!-- Popup (position: fixed, can go outside the chart) -->
    <div id="popup">
      <span class="close-btn" id="popupClose">&times;</span>
      <div id="popupContent"></div>
    </div>
  </main>
  
  <!-- Footer -->
  <footer>
    <div class="social-links">
      <a href="https://www.youtube.com/hansenspace" target="_blank">
        <img src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/youtube.svg" alt="YouTube">
      </a>
      <a href="https://instagram.com/hansenspace" target="_blank">
        <img src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/instagram.svg" alt="Instagram">
      </a>
      <a href="https://tiktok.com/@hansen_space" target="_blank">
        <img src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/tiktok.svg" alt="TikTok">
      </a>
    </div>
    <p style="font-size:16px; font-weight:bold;">&copy; 2025 Hansen Space.</p>
  </footer>
  
  <!-- Chart.js Library -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <!-- Global Chart.js font defaults -->
  <script>
    Chart.defaults.font.family = "Moon, sans-serif";
    Chart.defaults.font.size = 16;
    Chart.defaults.font.weight = "bold";
  </script>
  
  <!-- Global vertical line plugin (modular version) -->
  <script>
    const verticalLinePlugin = {
      id: 'verticalLinePlugin',
      afterDraw: function(chart) {
        const ctx = chart.ctx;
        const xScale = chart.scales.x;
        const yScale = chart.scales.y;
        
        // Draw fixed red line at x=0 and label "NOW" below.
        const fixedX = xScale.getPixelForValue(0);
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(fixedX, yScale.top);
        ctx.lineTo(fixedX, yScale.bottom);
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'red';
        ctx.stroke();
        ctx.restore();
        
        ctx.save();
        ctx.font = "bold 16px 'Moon Bold', sans-serif";
        ctx.fillStyle = 'red';
        ctx.textAlign = 'center';
        ctx.fillText("NOW", fixedX, yScale.bottom + 20);
        ctx.restore();
        
        let drawX = (chart.myStuckX != null) ? chart.myStuckX : chart.myHoverX;
        
        if (drawX != null && drawX >= xScale.left && drawX <= xScale.right) {
          const blueValue = xScale.getValueForPixel(drawX);
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(drawX, yScale.top);
          ctx.lineTo(drawX, yScale.bottom);
          ctx.lineWidth = 2;
          ctx.strokeStyle = 'darkblue';
          ctx.stroke();
          ctx.restore();
          
          let label = "";
          if (Math.abs(blueValue) < 0.01) {
            label = "Now";
          } else if (blueValue > 0) {
            label = "in " + blueValue.toFixed(2) + " days";
          } else {
            label = Math.abs(blueValue).toFixed(2) + " days ago";
          }
          ctx.save();
          ctx.font = "bold 16px 'Moon Bold', sans-serif";
          ctx.fillStyle = 'darkblue';
          ctx.textAlign = 'center';
          ctx.fillText(label, drawX, yScale.bottom + 20);
          ctx.restore();
        }
      }
    };
    
    Chart.register(verticalLinePlugin);
  </script>
  
  <!-- Modular chart initialization function -->
  <script>
    function initLightCurveChart(options) {
      // options: { canvasId, csvPath, starName }
      const canvas = document.getElementById(options.canvasId);
      const ctx = canvas.getContext("2d");
      
      let epochJD = null;
      let period = null;
      let originalScatterData = [];
      let myChart = null;
      
      function getCurrentJD() {
        return (Date.now() / 86400000) + 2440587.5;
      }
      
      async function fetchCSV(url) {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error("Failed to load CSV file.");
        }
        return response.text();
      }
      
      function parseCSV(csvText) {
        const lines = csvText.split("\n").filter(line => line.trim() !== "");
        if (lines.length === 0) return [];
        const firstLine = lines[0].split(",").map(s => s.trim());
        epochJD = parseFloat(firstLine[0]);
        period = parseFloat(firstLine[1]);
        const dataLines = lines.slice(1);
        originalScatterData = dataLines.map(line => {
          const parts = line.split(",").map(s => s.trim());
          const phase = parseFloat(parts[0]);
          const mag = parseFloat(parts[1]);
          return { phase: phase, mag: mag };
        }).filter(point => !isNaN(point.phase) && !isNaN(point.mag));
        return originalScatterData;
      }
      
      function transformData(currentPhase) {
        return originalScatterData.map(point => {
          let diff = point.phase - currentPhase;
          if (diff > 0.5) diff -= 1;
          if (diff < -0.5) diff += 1;
          return { x: diff * period, y: point.mag };
        });
      }
      
      function updateChart() {
        const jdNow = getCurrentJD();
        let currentPhase = ((jdNow - epochJD) / period) % 1;
        if (currentPhase < 0) currentPhase += 1;
        if (myChart) {
          const newData = transformData(currentPhase);
          myChart.data.datasets[0].data = newData;
          myChart.options.scales.x.min = -period / 2;
          myChart.options.scales.x.max = period / 2;
          myChart.update();
        }
      }
      
      // Format date as "YYYY-MM-DD HH:mm"
      function formatDateSimple(dt, utc = false) {
        let year = utc ? dt.getUTCFullYear() : dt.getFullYear();
        let month = (utc ? dt.getUTCMonth() : dt.getMonth()) + 1;
        let day = utc ? dt.getUTCDate() : dt.getDate();
        let hours = utc ? dt.getUTCHours() : dt.getHours();
        let minutes = utc ? dt.getUTCMinutes() : dt.getMinutes();
        return year + "-" +
               (month < 10 ? "0" + month : month) + "-" +
               (day < 10 ? "0" + day : day) + " " +
               (hours < 10 ? "0" + hours : hours) + ":" +
               (minutes < 10 ? "0" + minutes : minutes);
      }
      
      // Show popup using fixed coords from the click event.
      function showPopup(clickEvent, stuckPixelX) {
        const xScale = myChart.scales.x;
        const blueValue = xScale.getValueForPixel(stuckPixelX);
        let now = new Date();
        let targetTime = new Date(now.getTime() + blueValue * 86400000);
        
        const message = "UTC: <span class='dynamic'>" + formatDateSimple(targetTime, true) + "</span><br>" +
                        "LOCAL: <span class='dynamic'>" + formatDateSimple(targetTime) + "</span>";
        
        const popup = document.getElementById("popup");
        document.getElementById("popupContent").innerHTML = message;
        
        // Use event.clientX / clientY for the entire viewport
        let popupX = clickEvent.clientX + 10;
        let popupY = clickEvent.clientY + 10;
        popup.style.left = popupX + "px";
        popup.style.top = popupY + "px";
        popup.style.display = "block";
      }
      
      function closePopup() {
        myChart.myStuckX = null;
        document.getElementById("popup").style.display = "none";
        myChart.draw();
      }
      
      // Load CSV, parse data, create chart.
      fetchCSV(options.csvPath)
      .then(csvText => {
        parseCSV(csvText);
        const jdNow = getCurrentJD();
        let currentPhase = ((jdNow - epochJD) / period) % 1;
        if (currentPhase < 0) currentPhase += 1;
        const transformedData = transformData(currentPhase);
        
        myChart = new Chart(ctx, {
          type: "scatter",
          data: {
            datasets: [{
              label: options.starName,
              data: transformedData,
              backgroundColor: "rgba(75, 192, 192, 1)",
              pointRadius: 3,
              hoverRadius: 3
            }]
          },
          options: {
            responsive: false,
            hover: { mode: null },
            plugins: {
              legend: { display: false },
              tooltip: { enabled: false },
              title: {
                display: true,
                text: options.starName + " Light Curve",
                font: {
                  family: "Moon Bold, sans-serif",
                  size: 20,
                  weight: "bold"
                }
              }
            },
            scales: {
              x: {
                type: "linear",
                position: "bottom",
                min: -period / 2,
                max: period / 2,
                title: {
                  display: true,
                  text: "Time Offset (days)",
                  font: {
                    family: "Moon Bold, sans-serif",
                    size: 16,
                    weight: "bold"
                  }
                },
                ticks: {
                  font: {
                    family: "Moon Bold, sans-serif",
                    size: 16,
                    weight: "bold"
                  },
                  callback: function(value, index, ticks) {
                    const tickValues = ticks.map(t => t.value);
                    const min = tickValues[0];
                    const max = tickValues[tickValues.length - 1];
                    if (value === min || value === max) {
                      if (Math.abs(value) < 0.01) return "Now";
                      if (value < 0) return Math.abs(value).toFixed(2) + " days ago";
                      else return "in " + value.toFixed(2) + " days";
                    }
                    return "";
                  }
                }
              },
              y: {
                min: 3,
                max: 5,
                reverse: true,
                title: {
                  display: true,
                  text: "Magnitude",
                  font: {
                    family: "Moon Bold, sans-serif",
                    size: 16,
                    weight: "bold"
                  }
                },
                ticks: {
                  font: {
                    family: "Moon Bold, sans-serif",
                    size: 16,
                    weight: "bold"
                  }
                }
              }
            }
          }
        });
        
        // Initialize per-chart hover/stuck props
        myChart.myHoverX = null;
        myChart.myStuckX = null;
        
        // Mouse events
        canvas.addEventListener("mousemove", function(event) {
          const rect = canvas.getBoundingClientRect();
          if (
            event.clientX >= rect.left &&
            event.clientX <= rect.right &&
            event.clientY >= rect.top &&
            event.clientY <= rect.bottom
          ) {
            if (myChart.myStuckX === null) {
              myChart.myHoverX = event.clientX - rect.left;
            }
          } else {
            if (myChart.myStuckX === null) {
              myChart.myHoverX = null;
            }
          }
          myChart.draw();
        });
        
        canvas.addEventListener("mouseout", function() {
          if (myChart.myStuckX === null) {
            myChart.myHoverX = null;
          }
          myChart.draw();
        });
        
        canvas.addEventListener("click", function(event) {
          event.stopPropagation();
          const popup = document.getElementById("popup");
          // If popup is open, close it
          if (popup.style.display === "block") {
            closePopup();
            return;
          }
          // Otherwise lock line and show popup
          if (myChart.myStuckX === null && myChart.myHoverX !== null) {
            myChart.myStuckX = myChart.myHoverX;
            showPopup(event, myChart.myStuckX);
          }
        });
        
        // Document click: close if outside popup
        document.addEventListener("click", function(e) {
          const popup = document.getElementById("popup");
          if (popup.style.display === "block" && !popup.contains(e.target)) {
            closePopup();
          }
        });
        
        // Popup "×" close
        document.getElementById("popupClose").addEventListener("click", function(e) {
          e.stopPropagation();
          closePopup();
        });
        
        updateChart();
        setInterval(updateChart, 60000);
      })
      .catch(error => {
        console.error("Error loading or parsing CSV:", error);
      });
    }
    
    // Initialize chart for Delta Cephei
    initLightCurveChart({
      canvasId: "lightCurveChart",
      csvPath: "curves/DEL_CEP.csv",
      starName: "Delta Cephei"
    });
  </script>
</body>
</html>
